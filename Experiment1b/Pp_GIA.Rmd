---
title: "Pseudo Polgyon mode for GIA"
author: "Z Sha"
date: "31 October 2017"
output: html_document
---

***

## 0 Introduction

In this document, we apply the pseudo polygon method on GIA. The idea is that GIA is a stationary porcess on a subset of $S^2$. The subset is given by removing polygons where the values are certainly zero according to experts from the entire sphere.

## 1 Generate the polygons and mesh
First we generate the mesh for a discreate reparesentation of the GIA process. The mesh is restricted on a subset of the sphere defined by the pseudo-polygons. More details about choosing and generating the polygons can be found [here](http://rpubs.com/zs_sz/PseudoObs02). The following chunk generate the pseudo polygons using the ensemble mean of 13 GIA mode solutions for a given threshold value, say $0.2$.

```{r polygons, include=TRUE, eval=FALSE}
### Load the GIA forward solutions
if(Sys.info()["sysname"] == "Windows"){
  GIA_path <- "Z:/WP2-SolidEarth/GIAforwardModels/textfiles/" 
}else if(Sys.info()["sysname"] == "Ubuntu"){
GIA_path <- "~/globalmass/WP2-SolidEarth/GIAforwardModels/textfiles/" #(on ubuntu desktop )
}else{
GIA_path <- "/./projects/GlobalMass/WP2-SolidEarth/GIAforwardModels/textfiles/" #(on server)
}

file_names <- system(paste("ls", GIA_path), intern = TRUE)
## Remove unwanted files: no.13 ice6g-ewh, no.11 W&O-EGOD and readme files
file_names <- file_names[-c(1, 13, 16)]
GIA_name <- unlist(strsplit(file_names, split = ".txt"))
GIA_priors <- list()
for (i in 1:13){
GIA_priors[[i]] <- read.table(paste0(GIA_path, file_names[i]), header = T)
}
## create the ensemble data sets
GIA_ensemble <- GIA_priors[[1]]
GIA_ensemble$trend <- rowMeans(sapply(GIA_priors, "[[", "trend"))
GIA_ensemble$std <- sqrt((rowSums(sapply(GIA_priors, function(x) (x$std)^2)))/13)

## from Spatialpixels to raster to polygons
library(raster)
GIA_sp <- GIA_ensemble[, c(2,3,4,5)]
GIA_sp$inPoly <- abs(GIA_sp$trend) < 0.2
coordinates(GIA_sp) <- c("x_center", "y_center")
## Convert 0 ~ 360 to -180 ~ 180
GIA_sp@coords[,1] <- ifelse(GIA_sp@coords[,1] <=180, GIA_sp@coords[,1], GIA_sp@coords[,1]-360)
gridded(GIA_sp) <- TRUE

GIA_ras <- raster(GIA_sp, layer = 3) # 3 is the column no of inPoly
zeroPoly <- rasterToPolygons(GIA_ras, fun=function(inPoly) {inPoly == TRUE}, dissolve=TRUE )
plot(zeroPoly, col = "blue", main = "zero regions -- threshold = 0.2")
```

Next we generate the mesh and separate the triangles in/out-side of the polygons. We spread fibonacci points on the sphere as initial locations of the triangle vertices. The number of the points controls the resolution. The goal is to produce a map with approximately one degree resolution, hence we also need a similar resolution for the triangulation. Not that the triangle edge be no larger than the process correlation length. A one degree grid is about $110 \times 110 km$ which corresponds to a correlation length about $110/6371 = 0.017$. The number of triangles should be $f = 180 * 360 = 64800$ corresponding to number of vertices of $v \approx = (f+2)*2/5= 25921$.

```{r mesh, include=TRUE, eval=FALSE}
#### Generate Fibonacci points on the sphere
fiboSphere2 <- function(N = 1000L, L0 = FALSE) {
  ## Reference (note that points generated from 2D are slightly different from 3D)
  ## Measurement of Areas on a Sphere Using Fibonacci and Latitudeâ€“Longitude Lattices (2010)
  phi <- (sqrt(5) + 1) / 2 - 1 # golden ratio
  ga <- phi * 2 * pi           # golden angle

  i <- seq(-N, N)
  P <- 2 * N + 1
  lat <- asin(2*i / P) * 180 / pi
  if(L0){
  lon <- ((2 * pi * i / phi) %% pi) * 360 / pi
  }else{
    lon <- ((2 * pi * i / phi) %% pi) * 360 / pi - 180
    }
  cbind(lon = lon, lat = lat)
}


fibo_points <- fiboSphere2(N = 12960)
library(GEOmap);library(INLA)
if(Sys.info()['sysname'] == "Linux"){INLA:::inla.dynload.workaround()}
mesh_points_xyz <- do.call(cbind, Lll2xyz(lat = fibo_points[,2], lon = fibo_points[,1]))
mesh <- inla.mesh.2d(loc = mesh_points_xyz, cutoff = 0.01, max.edge = 0.5)
summary(mesh) # give the desired number of vertices and triangles.
```

Now separate the triangles by the pseudo-polygons.

```{r mesh2, include = TRUE}
source("C:/ZSwork/glbm/Experiment1b/mixture_model/BarrierModel/functions-barriers-dt-models-march2017.R")
mesh = dt.mesh.addon.posTri(mesh, globe = TRUE)
# - Add on mesh$posTri
# - - contains the positions of the triangles

## checking which mesh triangles are inside the land
## First convert xyz to lonlat
Tlonlat <- Lxyz2ll(list(x = mesh$posTri[,1], y = mesh$posTri[,2], z = mesh$posTri[,3]))
mesh$Trill <- cbind(lon = Tlonlat$lon, lat =Tlonlat$lat)
TinPoly <- unlist(over(zeroPoly, SpatialPoints(coords=mesh$Trill), returnList=T))
TAll <- 1:mesh$t
ToutPoly <- TAll[-TinPoly]
Omega = dt.Omega(list(TinPoly, 1:mesh$t), mesh)

## Plot the result in 3d
plot(mesh, t.sub = Omega[[2]], col = "lightblue", rgl = TRUE )
plot(mesh, t.sub = Omega[[1]], col = "yellow",  rgl = TRUE, add = TRUE)

## get the subset of the mesh for buiding the Q
mesh.sub <- function(mesh, Omega, i = 2){
  mesh_sub <- mesh
  id_tri <- Omega[[i]] # triangel id in the subset
  id_vet <- unique(as.vector(mesh$graph$tv[Omega[[i]], ])) # vertex id in the subset
  
  ## Now update the index for all
  id_all_v <- mesh$idx$loc
  id_all_v[-id_vet] <- NA
  id_all_v[which(!is.na(id_all_v))] <- 1:length(id_vet)
  
  id_all_t <- 1:mesh$t
  id_all_t[-id_tri] <- NA
  id_all_t[which(!is.na(id_all_t))] <- 1:length(id_tri)
  ## Modify the mesh to be the subset
  
  
  ## get the subset of the graph
  sub_tv <- mesh$graph$tv[Omega[[i]], ]
  sub_vt <- mesh$graph$vt[id_vet,]
  sub_tt <- mesh$graph$tt[Omega[[i]],]
  sub_tti <- mesh$graph$tti[Omega[[i]],]
  sub_vv <- mesh$graph$vv[id_vet,id_vet]
  
  ## Change the triangle indics of the subset
  sub_tv <- cbind(id_all_v[sub_tv[,1]], id_all_v[sub_tv[,2]], id_all_v[sub_tv[,3]])
  #sub_vt <- id_all_t[sub_vt]
  #sub_tt <- cbind(id_all_t[sub_tt[,1]], id_all_t[sub_tt[,2]], id_all_t[sub_tt[,3]])
  
  ## Now assemble 
  mesh_sub$t <- length(id_tri) 
  mesh_sub$n <- length(id_vet)
  mesh_sub$loc <- mesh_sub$loc[id_vet, ]
  mesh_sub$graph$tv <- sub_tv
  mesh_sub$graph$vt <- sub_vt
  mesh_sub$graph$tt <- sub_tt
  mesh_sub$graph$tti <- sub_tti
  mesh_sub$graph$vv <- sub_vv
  mesh_sub$idx$loc <- 1:length(id_vet)
  mesh_sub$posTri <- mesh_sub$posTri[Omega[[i]],]
  mesh_sub$Trill <- mesh_sub$Trill[Omega[[i]],]
  return(mesh_sub)
}

mesh_outPoly <- mesh.sub(mesh, Omega, 2)
plot(mesh_outPoly, rgl = TRUE)

mu_r <- 500/6371
v_r <- (1000/6371)^2
mu_s <- 20
v_s <- 40^2

## Transform the parameters for the SPDE_GMRF approximation
Tlognorm <- function(mu, v){
  logv <- log(1 + v/mu^2)
  logmu <- log(mu^2) - 0.5*log(mu^2 + v)
  return(c(logmu, logv))
}
trho <- Tlognorm(mu_r, v_r)
tsigma <- Tlognorm(mu_s, v_s)


 lsigma0 <- tsigma[1]
  theta1_s <- tsigma[2]
  lrho0 <- trho[1]
  theta2_s <- trho[2]
  lkappa0 <- log(8)/2 - lrho0
  ltau0 <- 0.5*log(1/(4*pi)) - lsigma0 - lkappa0
GIA_spde <- inla.spde2.matern(mesh_outPoly, B.tau = matrix(c(ltau0, -1, 1),1,3), B.kappa = matrix(c(lkappa0, 0, -1), 1,3),
                                theta.prior.mean = c(0,0), theta.prior.prec = c(sqrt(1/theta1_s), sqrt(1/theta2_s)))
Q <- inla.spde.precision(spde = GIA_spde, theta = c(0,0))
u <- inla.qsample(n=1, Q=Q, seed = 2)
  
```

## 2 Data preparation

## 2.1 GIA forward model solution
Load the GIA forward solution and project the values to the mesh grid
```{r gia_data, include=TRUE}
ice6g <- read.table("~/globalmass/WP2-SolidEarth/GIAforwardModels/textfiles/GIA_Pel-6-VM5.txt", header = T)

  polycoords <- ice6g[,c(6:13, 6,7)] 
  plist <- lapply(ice6g$ID, function(x) Polygons(list(Polygon(cbind(lon = as.numeric(polycoords[x, c(1,3,5,7,9)]), 
                                                                  lat = as.numeric(polycoords[x, c(2,4,6,8,10)])))), ID = x))
  Plist <- SpatialPolygons(plist, proj4string = CRS("+proj=longlat"))
  ## Convert the Cartesian to longlat with long in [0, 360)
  MlocLL <- Lxyz2ll(list(x=mesh$loc[,1], y = mesh$loc[,2], z = mesh$loc[,3]))
  MlocLL$lon <- ifelse(MlocLL$lon <0, MlocLL$lon + 359, MlocLL$lon)
  M_sp <- SpatialPoints(data.frame(lon = MlocLL$lon, lat = MlocLL$lat), proj4string = CRS("+proj=longlat")) 
  Midx <- over(M_sp, Plist)
  GIA_prior <- ice6g$trend[Midx]
  
```

## 2.2 GPS data

Load the processed GPS data and remove those inside the pseudo-polygons. Stitch the polygon boundaries with pseudo observations.

```{r data, include = TRUE}
GPSV3d <- read.table("~/globalmass/WP2-SolidEarth/GPS_version03/GPSdataset_v03c_QC_20170809_comb.txt", header = T)

GPS_inPoly <- unlist(over(zeroPoly, SpatialPoints(coords = cbind(GPSV3d$lon, GPSV3d$lat)), returnList=T))
GPS_All <- 1:nrow(GPSV3d)
GPS_outPoly <- GPS_All[-GPS_inPoly]
plot(GPSV3d[GPS_outPoly,c("lon", "lat")], pch = "+")

GPS_data <- GPSV3d[GPS_outPoly,]
GPS_loc <- do.call(cbind, Lll2xyz(lat = GPS_data$lat, lon = GPS_data$lon))
GPS_sp <- SpatialPoints(data.frame(lon = GPS_data$lon, lat = GPS_data$lat), proj4string = CRS("+proj=longlat"))
Midx2 <- over(GPS_sp, Plist)
GPS_mu <- ice6g$trend[Midx2]
GPS_data$trend0 <- GPS_data$trend - GPS_mu

```

## 3 Inference -- mixture model
```{r barrier, include = TRUE}
Q.mixture = dt.create.Q(mesh, Omega, fixed.ranges = c(5, NA))
# - We fix the barrier range to a different value than we 
#   used for simulations
# - - Why? It does not matter, as long as it is 'small' 
#     the models are very
#     similar
# - - This shows that you do not need to know the 
#     true 'barrier range'!

log.prior = dt.create.prior.log.exp(prior.param = c(1,1))
# - The prior parameters are the lambdas in the exponential 
#   priors for standard deviation and inverse-range

mixture.model = dt.inla.model(Q = Q.mixture, log.prior=log.prior)

formula2 <- y ~ -1 + f(s, model=mixture.model)
# - The spatial model component is different from before
# - The rest of the model setup is the same! 
#   (as in the stationary case)
# - - e.g. the inla(...) call below is the same, 
#     only this formula is different

res.mixture = inla(formula2, data=inla.stack.data(stk1),
       control.predictor=list(A = inla.stack.A(stk1)),
       family = 'gaussian',
       control.family = list(hyper = hyper),
            scale = scales)

summary(res.mixture)
theta1 <- res.mixture$marginals.hyperpar$`Theta1 for s`
theta2 <- res.mixture$marginals.hyperpar$`Theta2 for s`

Vmar<- inla.tmarginal(exp, theta1)
Rmar <- inla.tmarginal(exp, theta2)

plot(Vmar, type = "l", main = "posterior varianace")
plot(Rmar, type = "l", main = "posterior range")

local.plot.field(res.mixture$summary.random$s$mean, asp = 1,zlim = c(-25, 20),
                 main="Spatial posterior for mixture model -- mean")
plot(Ocean, add = TRUE)
plot(obs_all, pch = ".", add = TRUE)

local.plot.field(res.mixture$summary.random$s$sd, asp = 1, 
                 main="Spatial posterior for mixture model -- uncertainty")
plot(Ocean, add = TRUE)
plot(obs_all, pch = ".", add = TRUE)

```