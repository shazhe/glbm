---
title: "Estimating GIA -- 1 Stationary on sphere"
author: "Z Sha"
date: "13 November 2017"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---


# Introduction

In this study, we apply the Bayesian data assimilation model on updatding the global GIA process by using GPS data. We use the soluton from the ICE6G-VM5 model as our prior mean for the GIA process. The GPS data are processed into yearly vertical bedrock movement from a selected global network. 

Here we first assume the updating process is stationary on the sphere; then we remove the stationarity constraint by using the information of expert defined pseudo polygons where the GIA should be zero in theroy. Three different approaches are used in modelling the non-stationarity:

(1) Use pseudo-polygon observations --- [***Polygon observation***](http://rpubs.com/zs_sz/gia02)

(2) Use pseudo-polygons to define the subset where GIA can be modelled as stationary process --- [***Subset model***](http://rpubs.com/zs_sz/gia03)

(3) Use psdeuo-polygons to define a mixture Gaussian process where the updating process has different spatial properties inside and outside of the pseudo-polygons --- [***Mixture model***](http://rpubs.com/zs_sz/gia04)

In the following, we demonstrate the global statinary approach step by step.


# Data and prior

First we setup the data and prior. Note that the ICE6G solution is given on a 1 degree grid. For any given location, we define the GIA prior to be the value of the grid in which the location falls.

## GIA forward model solution

Load the GIA forward solution and define it as a spatial polygon data set.

```{r load_pack, message = FALSE, warning=FALSE}
library(sp); library(INLA); library(GEOmap)
library(ggplot2); library(grid); library(gridExtra)
source("functions.R")
```

```{r load_data0, include=FALSE, eval = TRUE, cache = TRUE}
#### 1 Load GIA prior
if(Sys.info()["sysname"] == "Windows"){
  ice6g <- read.table("Z:/WP2-SolidEarth/BHMinputs/GIA/GIA_Pel-6-VM5.txt", header = T)
}else if(grep("Ubuntu",Sys.info()["version"]) == 1){
  ice6g <- read.table("~/GMdata/BHMinputs/GIA/GIA_Pel-6-VM5.txt", header = T)
}else{
  ice6g <- read.table("/./projects/GlobalMass/WP2-SolidEarth/BHMinputs/GIA/GIA_Pel-6-VM5.txt", header = T)
}

polycoords <- ice6g[,c(6:13, 6,7)] 
plist <- lapply(ice6g$ID, 
                function(x) Polygons(list(Polygon(cbind(lon = as.numeric(polycoords[x, c(1,3,5,7,9)]), 
                                                        lat = as.numeric(polycoords[x, c(2,4,6,8,10)])))), ID = x))
Plist <- SpatialPolygons(plist, proj4string = CRS("+proj=longlat"))


#### 2 Load GPS data
if(Sys.info()["sysname"] == "Windows"){
  GPSV4b <- read.table("Z:/WP2-SolidEarth/BHMinputs/GPS/GPS_v04b.txt", header = T)
}else if(grep("Ubuntu",Sys.info()["version"]) == 1){
  GPSV4b <- read.table("~/GMdata/BHMinputs/GPS/GPS_v04b.txt", header = T)
}else{
  GPSV4b <- read.table("/./projects/GlobalMass/WP2-SolidEarth/BHMinputs/GPS/GPS_v04b.txt", header = T)
}
```

```{r gia_data, include=TRUE, eval = FALSE}
ice6g <- read.table("ice6g.txt", header = T)
polycoords <- ice6g[,c(6:13, 6,7)] 
plist <- lapply(ice6g$ID, 
                function(x) Polygons(list(Polygon(cbind(lon = as.numeric(polycoords[x, c(1,3,5,7,9)]), 
                                                        lat = as.numeric(polycoords[x, c(2,4,6,8,10)])))), ID = x))
Plist <- SpatialPolygons(plist, proj4string = CRS("+proj=longlat"))
## Note that in this data set the grid boundaries are defined on [-0.5, - 359.5] and the centre points on [0, 359].
## Corresponding transformation is needed in the following in geometery operations.
```

The GIA process will be approximated on a triangular mesh with piece-wise linear basis functions, we will only use the GIA values at the triangle vertices to represent the processes. The following generate a semi-regular mesh on a sphere with approximately 1 degree resolution and we define the GIA prior to be GIA values at the mesh nodes. The semi-regular mesh is generated by using Fibonacci points as intial locations. The Fibonacci points are approximately evenly distributed on the sphere. The goal is to produce a map with approximately one degree resolution, hence we also need a similar resolution for the triangulation. Note that the triangle edge be no larger than the process correlation length. A one degree grid is about $110 \times 110 km$ which corresponds to a correlation length about $110/6371 = 0.017$. The number of triangles should be $f = 180 * 360 = 64800$ corresponding to number of vertices of $v \approx  (f+2)*2/5= 25921$.
```{r fibo_mesh, include=TRUE}
fibo_points <- fiboSphere(N = 12960, L0 = TRUE)
fibo_points_xyz <- do.call(cbind, Lll2xyz(lat = fibo_points[,2], lon = fibo_points[,1]))
mesh <- inla.mesh.2d(loc = fibo_points_xyz, cutoff = 0.01, max.edge = 0.5)
summary(mesh)
```

Now find the GIA value at the mesh nodes.
```{r GIA_mesh, include=TRUE, eval = TRUE, cache = TRUE}
meshLL <- Lxyz2ll(list(x=mesh$loc[,1], y = mesh$loc[,2], z = mesh$loc[,3]))
meshLL$lon <- ifelse(meshLL$lon >= -0.5, meshLL$lon,meshLL$lon + 360)
mesh_sp <- SpatialPoints(data.frame(lon = meshLL$lon, lat = meshLL$lat), proj4string = CRS("+proj=longlat")) 
mesh_idx <- over(mesh_sp, Plist)
GIA_prior <- ice6g$trend[mesh_idx]
```

## GPS data

Load the GPS data.
```{r loadGPS, include = TRUE, eval = FALSE}
GPSV4b <- read.table("GPS_Versionx.txt", header = T)
## The original GPS data use lon in [0, 360]
```

Detrend the GPS data by the GIA prior.
```{r GPSdetrend, include = TRUE}
GPS_data <- GPSV4b
GPS_loc <- do.call(cbind, Lll2xyz(lat = GPS_data$lat, lon = GPS_data$lon))
GPS_sp <- SpatialPoints(data.frame(lon = ifelse(GPS_data$lon>359.5, GPS_data$lon - 360, GPS_data$lon), 
                                   lat = GPS_data$lat), proj4string = CRS("+proj=longlat"))
GPS_idx <- over(GPS_sp, Plist)
GPS_mu <- ice6g$trend[GPS_idx]
GPS_data$trend0 <- GPS_data$trend - GPS_mu
```

## Consider pseudo polygons

We might also want to consider pseudo polygon at this stage. There are two approaches in dealing with GPS observations in the pseudo polygons: (1) remove them; (2) change their values. In the following, we assemble two GPS data for testing the effect of these two approaches.

```{r polygons, message = FALSE, cache = TRUE}
## Load the pseudo polygon
zeroPolygon <- readOGR(dsn = "/./projects/GlobalMass/WP1-BHM/Experiment1b/shapefiles", layer = "zero03")

## Remove polygons that are too small
zeroPolys <- zeroPolygon@polygons[[1]]@Polygons
polyareas <- sapply(zeroPolys, function(x) x@area)
polyholes <- sapply(zeroPolys, function(x) x@hole)
zeropolys2 <- zeroPolys[polyareas > 200 ] 
zeroPoly <- zeroPolygon
zeroPoly@polygons[[1]]@Polygons <- zeropolys2

## Remove GPS data inside the polygon
GPS_inPoly <- unlist(over(zeroPoly, SpatialPoints(coords = cbind(GPSV4b$lon, GPSV4b$lat)), returnList=T))
GPS_All <- 1:nrow(GPS_data)
GPS_outPoly <- GPS_All[-GPS_inPoly]

GPS_data2 <- GPS_data[GPS_outPoly,]
GPS_loc2 <- GPS_loc[GPS_outPoly,]

## Find the mesh nodes incide the polygons
GPS_data3 <- GPS_data
GPS_data3[GPS_inPoly, "trend"] <- 0
GPS_data3[GPS_inPoly, "trend0"] <- -GPS_mu[GPS_inPoly]
GPS_data3[GPS_inPoly, "std"] <- 0.01

```



## Prior setup for the parameters

Setup the priors for the parameters for the Gaussian process. Assume the prior distributions of both $\rho$ and $\sigma^2$ are log normal. The prior mean of the correlation length is set to be 500km based on expert prior opinion on the residual process and the mean for the variance is 20 which is about the range of the GIA values. The variances of both distributions are set to be large for a vague enough prior.
```{r prior}
## Priors mean and variance for the parameters: rho and sigma
mu_r <- 500/6371
v_r <- (1000/6371)^2
mu_s <- 20
v_s <- 40^2

## Transform the parameters for the SPDE_GMRF approximation
trho <- Tlognorm(mu_r, v_r)
tsigma <- Tlognorm(mu_s, v_s)
```


# Inference by INLA

We use INLA to do the estimation and prediction of the global stationary model. First set up the INLA model.
```{r inla_setup, include = TRUE, cache = TRUE}
Mesh_GIA <- mesh
## The SPDE model
lsigma0 <- tsigma[1]
theta1_s <- tsigma[2]
lrho0 <- trho[1]
theta2_s <- trho[2]
lkappa0 <- log(8)/2 - lrho0
ltau0 <- 0.5*log(1/(4*pi)) - lsigma0 - lkappa0
GIA_spde <- inla.spde2.matern(Mesh_GIA, B.tau = matrix(c(ltau0, -1, 1),1,3), B.kappa = matrix(c(lkappa0, 0, -1), 1,3),
                              theta.prior.mean = c(0,0), theta.prior.prec = c(sqrt(1/theta1_s), sqrt(1/theta2_s)))

## Link the process to observations and predictions
A_data1 <- inla.spde.make.A(mesh = Mesh_GIA, loc = GPS_loc)
A_pred1 <- inla.spde.make.A(mesh = Mesh_GIA, loc = rbind(GPS_loc, Mesh_GIA$loc))
## Create the estimation and prediction stack
st.est1 <- inla.stack(data = list(y=GPS_data$trend0), A = list(A_data1),
                     effects = list(GIA = 1:GIA_spde$n.spde), tag = "est")
st.pred1 <- inla.stack(data = list(y=NA), A = list(A_pred1),
                      effects = list(GIA=1:GIA_spde$n.spde), tag = "pred")
stGIA1 <- inla.stack(st.est1, st.pred1)
## Fix the GPS errors
hyper <- list(prec = list(fixed = TRUE, initial = 0))
formula = y ~ -1 +  f(GIA, model = GIA_spde)
prec_scale1 <- c(1/GPS_data$std^2, rep(1, nrow(A_pred1)))

## Link the process to observations and predictions
A_data2 <- inla.spde.make.A(mesh = Mesh_GIA, loc = GPS_loc2)
A_pred2 <- inla.spde.make.A(mesh = Mesh_GIA, loc = rbind(GPS_loc2, Mesh_GIA$loc))
## Create the estimation and prediction stack
st.est2 <- inla.stack(data = list(y=GPS_data2$trend0), A = list(A_data2),
                     effects = list(GIA = 1:GIA_spde$n.spde), tag = "est")
st.pred2 <- inla.stack(data = list(y=NA), A = list(A_pred2),
                      effects = list(GIA=1:GIA_spde$n.spde), tag = "pred")
stGIA2 <- inla.stack(st.est2, st.pred2)
prec_scale2 <- c(1/GPS_data2$std^2, rep(1, nrow(A_pred2)))

## Link the process to observations and predictions
A_data3 <- inla.spde.make.A(mesh = Mesh_GIA, loc = GPS_loc)
A_pred3 <- inla.spde.make.A(mesh = Mesh_GIA, loc = rbind(GPS_loc, Mesh_GIA$loc))
## Create the estimation and prediction stack
st.est3 <- inla.stack(data = list(y=GPS_data3$trend0), A = list(A_data3),
                     effects = list(GIA = 1:GIA_spde$n.spde), tag = "est")
st.pred3 <- inla.stack(data = list(y=NA), A = list(A_pred3),
                      effects = list(GIA=1:GIA_spde$n.spde), tag = "pred")
stGIA3 <- inla.stack(st.est3, st.pred3)
prec_scale3 <- c(1/GPS_data3$std^2, rep(1, nrow(A_pred3)))


```

Then we run the INLA model. Note that this will take more than 10min and require memory larger than 32GB. We ran this on a server with 56 cores and 256GB memory.
```{r inla_run, include = TRUE, eval = FALSE}
## Run INLA
res_inla1 <- inla(formula, data = inla.stack.data(stGIA1, spde = GIA_spde), family = "gaussian",
                 scale =prec_scale1, control.family = list(hyper = hyper),
                 control.predictor=list(A=inla.stack.A(stGIA1), compute =TRUE))

res_inla2 <- inla(formula, data = inla.stack.data(stGIA2, spde = GIA_spde), family = "gaussian",
                 scale =prec_scale2, control.family = list(hyper = hyper),
                 control.predictor=list(A=inla.stack.A(stGIA2), compute =TRUE))

res_inla3 <- inla(formula, data = inla.stack.data(stGIA3, spde = GIA_spde), family = "gaussian",
                 scale =prec_scale3, control.family = list(hyper = hyper),
                 control.predictor=list(A=inla.stack.A(stGIA3), compute =TRUE))
```

# Analyse results

Now assemble the inla inference and prediction results.
```{r inla_res, include = TRUE, cache=TRUE}

resfun <- function(res_inla, GPSdata){
INLA_pred <- res_inla$summary.linear.predictor
## Extract and project predictions
pred_idx <- inla.stack.index(stGIA, tag = "pred")$data
GPS_idx <- pred_idx[1:nrow(GPS_data)]
GIA_idx <- pred_idx[-(1:nrow(GPS_data))]
## GPS 
GPS_u <- INLA_pred$sd[GPS_idx]
GPS_pred <- data.frame(lon = GPS_data$lon, lat = GPS_data$lat, u = GPS_u)
## GIA
GIA_diff <- INLA_pred$mean[GIA_idx] 
GIA_m <- GIA_diff + GIA_prior
GIA_u <- INLA_pred$sd[GIA_idx]
proj <- inla.mesh.projector(Mesh_GIA, projection = "longlat", dims = c(360,180), xlim = c(0,360), ylim = c(-90, 90))
GIA_grid <- expand.grid(proj$x, proj$y)
GIA_pred <- data.frame(lon = GIA_grid[,1], lat = GIA_grid[,2],
                       diff = as.vector(inla.mesh.project(proj, as.vector(GIA_diff))),
                       mean = as.vector(inla.mesh.project(proj, as.vector(GIA_m))),
                       u = as.vector(inla.mesh.project(proj, as.vector(GIA_u))))

return(list(res_inla = res_inla, spde = GIA_spde, st = stGIA, 
            mesh = Mesh_GIA, GPS_pred = GPS_pred, GIA_pred = GIA_pred))
}

ress1.1 <- resfun(res_inla = res_inla1, GPSdata = GPS_data)
ress1.2 <- resfun(res_inla = res_inla2, GPSdata = GPS_data2)
ress1.3 <- resfun(res_inla = res_inla3, GPSdata = GPS_data3)
save(ress1.1, ress1.2, ress1.3, file = "/./projects/GlobalMass/WP1-BHM/Experiment1b/GIA_RGL/res1.RData")
```


## Plot the posteriors of the hyper parameters.

```{r hyper, include=TRUE}
load("~/GMdata/GIA_RGL/res1.RData")
pars_pm1 <- marginal_par(res = ress1.1)
pars_pm2 <- marginal_par(res = ress1.2)
pars_pm3 <- marginal_par(res = ress1.3)

par(mfrow = c(1,2))
## The posterior distributions
plot(pars_pm1$Vmar, type = "l", xlim = c(1, 4.5), ylim = c(0, 17), 
     ylab = "posterior density", xlab = bquote(bold({sigma^2})))
lines(pars_pm2$Vmar, col = 2)
lines(pars_pm3$Vmar, col = 4)
legend("topright", c("GPS_all",  "GPS_sub", "GPS_new"), lty = rep(1,3), col = c(1,2,4))

plot(pars_pm1$Rmar, type = "l", xlim = c(0.05, 0.15), ylim = c(0, 180),
     ylab = "posterior density", xlab = bquote(bold({rho})))
lines(pars_pm2$Rmar, col = 2)
lines(pars_pm3$Rmar, col = 4)
legend("topright", c("GPS_all",  "GPS_sub", "GPS_new"), lty = rep(1,3), col = c(1,2,4))
```


## Plot the predictions.

```{r predict, include=TRUE}
ress1.1$GIA_pred$model <- "GPS_all"
ress1.2$GIA_pred$model <- "GPS_sub"
ress1.3$GIA_pred$model <- "GPS_new"
pred_all <- do.call(rbind, list(ress1.1$GIA_pred, ress1.2$GIA_pred, ress1.3$GIA_pred))
pred_all$model <- factor(pred_all$model, levels = c("GPS_all", "GPS_sub", "GPS_new"))
## The predicted mean
level_GIA(pred_data = pred_all, var = "mean", style ="zero", layout = c(1, 3), title = "predicted GIA mean field (mm/yr)")

## The predicted uncertainties
level_GIA(pred_data = pred_all, var = "u", style ="positive",layout = c(1, 3), title = "predicted GIA uncertanties (mm/yr)")

## The difference between the predicted mean and prior mean
level_GIA(pred_data = pred_all, var = "diff", style ="zero", layout = c(1, 3), title = "predicted GIA mean field - prior mean (mm/yr)")

```
