---
title: "Define Pseudo Observation Polygons -- Version 02"
author: "Z Sha"
date: "21 September 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Find suitable area for defining pseudo observation polygons

In this document, we use the 14 GIA forward model solutions to find regions where the observations are certain and close to zero. The 13 GIA forward model solutions are given at 1 degree resolution with the mean trend and estimated errors.

In the following we explore the data sets individually as well as in an ensemble approach.

### 0 Load useful packages and the data

```{r load, message = FALSE}
### Load the 14 GIA data 
data_path <- "Z:/WP2-SolidEarth/BHMinputs/GIA/"
file_names <- system(paste("ls", data_path), intern = TRUE)[1:15]
## Remove the no1-4 old version of peltier vm, no.12 W&O-EGOD
file_names <- file_names[-c(1:4,7, 11, 12)]
GIA_name <- unlist(strsplit(file_names, split = ".txt"))
GIA_priors <- list()
for (i in 1:8){
GIA_priors[[i]] <- read.table(paste0(data_path, file_names[i]), header = T)
}

## create the ensemble data sets
GIA_ensemble <- GIA_priors[[1]]
GIA_ensemble$trend <- rowMeans(sapply(GIA_priors, "[[", "trend"))
GIA_ensemble$std <- sqrt((rowSums(sapply(GIA_priors, function(x) (x$std)^2)))/8)
```

### 1 Criteria for selecting zero-value regions
To select the reasonable regions where the GIA are zero with high certainty, we first examine the distributions of the GIA values from the 13 forward models and their ensemble mean.
```{r eda, message = FALSE}
## All 13 datasets together
alltrend <- sapply(GIA_priors, "[[", "trend")
range(alltrend)
boxplot.stats(alltrend)$conf

## the esemble mean
range(GIA_ensemble$trend)
boxplot.stats(GIA_ensemble$trend)$conf
```

Plot the original 13 dataset and the ensemble means.
```{r eda_plot}
## combine the 13 lists to one dataframe
alltrend <- data.frame(alltrend)
names(alltrend) <- c("Pel6VM5", "Pur6VM5", "SnS3", "SKMOR", "SVv3REF", "WnW4", "WnW5", "vdW5")    
alltrend$ensemble <- GIA_ensemble$trend
alltrend$x_center <- GIA_priors[[1]]$x_center
alltrend$y_center <- GIA_priors[[1]]$y_center

library(sp)
raw_trend <- alltrend
coordinates(raw_trend) <- c("x_center", "y_center")
gridded(raw_trend) <- TRUE

brks <- seq(-8.5, 25.5, 2)
colpal <- colorRamps::matlab.like(length(brks) - 1)
spplot(raw_trend,  colorkey = list(at = brks), col.regions=colpal)
```


Rescale the colorbar to show more details for values within [-2, 2].
```{r eda_plot2}
plot_rescale <- function(breaks, abs = FALSE, title = NULL){
  n.brks <- length(breaks)
  if(abs){
    trends<- lapply(abs(alltrend[,1:11]), function(x) cut(x, breaks))
  }else{
     trends<- lapply(alltrend[,1:11], function(x) cut(x, breaks))
  }
  new_trend <- do.call(data.frame, trends)
  new_trend$x_center <-alltrend$x_center
  new_trend$y_center <- alltrend$y_center
  
  colpal <- colorRamps::matlab.like(n.brks-1)
  coordinates(new_trend) <- c("x_center", "y_center")
  gridded(new_trend) <- TRUE
  spplot(new_trend,  col.regions=colpal, main = list(title))
  
}


breaks <- c(-8.5, -2, -1, -0.5, -0.1, 0, 0.1, 0.5, 1, 2, 25.5)
plot_rescale(breaks)

```

Remove signs and rescale the colorbar down to details within 0.5 in absolute value.
```{r eda_plot3}
breaks <- c( 0, 0.1, 0.2, 0.5, 1, 25.5)
plot_rescale(breaks, abs = TRUE)
```

Down to the value of 0.5, most of the plots are very similar to each other except for trend3. They include most of the zero value regions. For a final comparison, we plot the zero value regions with threshold 0.1, 0.2, 0.3 and 0.5.
```{r eda_plot4}

## 0.1
breaks <- c(0, 0.1, 25.5)
plot_rescale(breaks, abs = TRUE, title = "threshold = 0.1")

## 0.2
breaks <- c(0, 0.2, 25.5)
plot_rescale(breaks, abs = TRUE, title = "threshold = 0.2")

## 0.3
breaks <- c(0, 0.3, 25.5)
plot_rescale(breaks, abs = TRUE, title = "threshold = 0.3")

## 0.4
breaks <- c(0, 0.4, 25.5)
plot_rescale(breaks, abs = TRUE, title = "threshold = 0.4")
```

The map using ensemble mean and thresholds at 0.3 looks reasonable and we use it in the following processing.


### 2 Create the zero value polygons.
Now we convert the region defined by the above criteria from pixels to polygons.
```{r polygons}
## from Spatialpixels to raster to polygons
library(raster)
GIA_sp <- GIA_ensemble[, c(2,3,4,5)]
GIA_sp$trend01 <- abs(GIA_sp$trend) <0.3
coordinates(GIA_sp) <- c("x_center", "y_center")
gridded(GIA_sp) <- TRUE


GIA_ras01 <- raster(GIA_sp, layer = 3) # 3 is the column no of trend01
zeroPoly01 <- rasterToPolygons(GIA_ras01, fun=function(trend01) {trend01 == TRUE}, dissolve=TRUE ) 
plot(zeroPoly01, col = "blue", main = "zero regions -- threshold = 0.3")
```

Note that there are holes in the large polygons and check if they are correctly labeled.
```{r holes}
sapply(zeroPoly01@polygons[[1]]@Polygons, function(x) slot(x, "hole"))
```

We can convert the spatialPolygonDataFrame object to a data frame that can be plotted by ggplot2.
```{r ggpolygons}
library(broom)
library(ggplot2)

GIA_zeroDF01 <- tidy(zeroPoly01)
zeropoly_map01 <- ggplot()+ coord_fixed()+ geom_polygon(data = GIA_zeroDF01, aes(x=long, y=lat, group = group, fill = !hole),colour="black") + ggtitle("Threshold = 0.1")

print(zeropoly_map01)
```


### 3 Generate Pseudo observations within the zero polygons
First, generate vertices that evenly distributed over the entire globe. The distance between the vertices is about the same as the correlation length of the of the residual process, which is about 400-500km apart. This is about spreading 3000 points using the Fibonacci spiral on a sphere.
```{r pseudobs}
## xyz -- Generate equally distributed points around a sphere -- Fibonacci spiral
fiboSphere1 <- function(n = 1000L) {
  
  phi <- (sqrt(5) + 1) / 2  # golden ratio
  i <- seq(-(n-1), (n-1),2)
  theta <- 2 * pi * i / phi
  sphi <- i/n
  cphi <- sqrt((n+i) * (n-i))/n
  
  x <- cphi * sin(theta)
  y <- cphi * cos(theta)
  z <- sphi
  return(cbind(x,y,z))
}

fiboSphere2 <- function(N = 1000L, L0 = FALSE) {
  ## Reference (note that points generated from 2D are slightly different from 3D)
  ## Measurement of Areas on a Sphere Using Fibonacci and Latitudeâ€“Longitude Lattices (2010)
  phi <- (sqrt(5) + 1) / 2 - 1 # golden ratio
  ga <- phi * 2 * pi           # golden angle

  i <- seq(-N, N)
  P <- 2 * N + 1
  lat <- asin(2*i / P) * 180 / pi
  if(L0){
  lon <- ((2 * pi * i / phi) %% pi) * 360 / pi
  }else{
    lon <- ((2 * pi * i / phi) %% pi) * 360 / pi - 180
    }
  cbind(lon = lon, lat = lat)
}

fibopoints <- fiboSphere2(N = 1000) 
fibopoints <- data.frame(fibopoints)
fibopoints$lon <- ifelse(fibopoints$lon < 0, fibopoints$lon+360, fibopoints$lon)


## Plot these points 
world_map <- map_data("world2")
map_fibo <- ggplot() + coord_fixed() + 
  geom_polygon(data=world_map, aes(x=long, y=lat, group=group), colour="black", fill = NA)  + 
  geom_point(data=data.frame(fibopoints), aes(x=lon, y=lat), pch=19, col = "blue", alpha=0.5)  + 
  ggtitle("Points evenly distributed on the sphere")

map_fibo
```

Then remove points that are not in the zero region polygons.
```{r rePoly01}
fibsp <- SpatialPoints(fibopoints, proj4string = CRS("+proj=longlat"))
zeroPolys01 <- SpatialPolygons(zeroPoly01@polygons, proj4string = CRS("+proj=longlat"))
fibin01 <- over(fibsp, zeroPolys01)
fibin01 <- ifelse(is.na(fibin01), FALSE, TRUE)
## plot these points
fibpoint_in01 <- data.frame(fibopoints[fibin01, ])

map_fiboZero01 <- zeropoly_map01 + geom_point(data=fibpoint_in01, aes(x=lon, y=lat), pch=19, 
                                    col = "blue", alpha=0.5)  + ggtitle("fibpoints in the zero polygons -- threshold = 0.2")
map_fiboZero01
```


### 4 Exclude the GPS area
Given the zero value region, we also want to exclude the region that include real GPS readings. Now we plot the latest GPS data for inspection.
```{r GPSdata}
GPS_data <- read.table("Z:/WP2-SolidEarth/BHMinputs/GPS/GPS_v03d.txt",  header = T)
GPS_data$lon <- ifelse(GPS_data$lon < 0, GPS_data$lon + 360, GPS_data$lon)

world_map <- map_data("world2")
map_GPS <-  ggplot() + coord_fixed() + geom_polygon(data=world_map, aes(x=long, y=lat, group=group), colour="black", fill = NA) + geom_point(data=GPS_data, aes(x=lon, y=lat), pch=19, 
                                    col = "red", fill = "red", alpha=0.7) + ggtitle("Real GPS observations")
map_GPS 
```

We remove points that are too close to the GPS observations (say within the correlation length 400-500km , that is about 5 degree in longlat).
```{r reGPS01a, cache=TRUE}
fibin01gps <- apply(fibpoint_in01, 1, function(x) all(apply(GPS_data[,2:3], 1, function(y) dist(rbind(y, x)) > 5)))
fibpoint_in01gps <- fibpoint_in01[fibin01gps,]
```

```{r reGPS01b}
map_fibo01 <- zeropoly_map01 + geom_point(data=fibpoint_in01gps, aes(x=lon, y=lat), pch=19, 
                                    col = "blue", alpha=0.5)  +
  geom_point(data=GPS_data, aes(x=lon, y=lat), pch=19, 
                                    col = "red", fill = "red", alpha=0.7) +
  ggtitle("fibpoints in the zero polygons and away from GPS -- threshold = 0.2")
map_fibo01
```

Finally, assemble the pseudo observation and real observation into the same data set. The pseudo observations are all zero and ***the related uncertainty is set to be tenth of the threshold values.***
```{r assemble01}
nps01 <- nrow(fibpoint_in01gps)
pseudo_data01 <- data.frame(ID = rep("pseudo", nps01), lon = fibpoint_in01gps$lon, lat = fibpoint_in01gps$lat, 
                          trend = 0, std = 0.01)
obs_all01 <- rbind(GPS_data, pseudo_data01)
obs_all01$source <- ifelse(obs_all01$ID == "pseudo", "pseudo", "real")

map_final01 <- ggplot() + coord_fixed() + geom_polygon(data=world_map, aes(x=long, y=lat, group=group), colour="black", fill = NA) + 
  geom_polygon(data = GIA_zeroDF01, aes(x=long, y=lat, group = group), colour="red", fill = NA) +
  geom_point(data=obs_all01, aes(x=lon, y=lat, colour = source), pch=19) + 
  ggtitle("Final map of real and pseudo observations -- threhold = 0.2")

map_final01
```

Plot with another projection.
```{r projection01}
library(mapproj)
map_final01 + coord_map(projection = "orthographic")
```




Finally, assemble the data and plot.
```{r assemble}
nps01 <- nrow(fibpoint_in01gps)
pseudo_data01 <- data.frame(ID = rep("pseudo", nps01), lon = fibpoint_in01gps$lon, lat = fibpoint_in01gps$lat, 
                          trend = 0, std = 0.03)
obs_all01 <- rbind(GPS_data, pseudo_data01)
obs_all01$source <- ifelse(obs_all01$ID == "pseudo", "pseudo", "real")

write.table(obs_all01, file = "Z:/WP1-BHM/Experiment1b/GIA_RGL/pseudo01.txt", 
            row.names = FALSE, eol = "\r\n")

map_final01 <- ggplot() + coord_fixed() + geom_polygon(data=world_map, aes(x=long, y=lat, group=group), colour="black", fill = NA) + 
  geom_polygon(data = GIA_zeroDF01, aes(x=long, y=lat, group = group), colour="red", fill = NA) +
  geom_point(data=obs_all01, aes(x=lon, y=lat, colour = source), pch=19) + 
  ggtitle("Final map of real and pseudo observations -- threshold = 0.3")

map_final01

map_final01 + coord_map(projection = "orthographic")
```


### 7 Output the polygons
```{r writePoly, eval = FALSE}
library(rgdal)
outpath <- "Z:/WP1-BHM/Experiment1b/shapefiles"
writeOGR(zeroPoly01, dsn = outpath, layer = "zero02", driver="ESRI Shapefile")
```
