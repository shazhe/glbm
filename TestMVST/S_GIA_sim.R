##################################################################################
##       Test script for simulate and estimate a univariate process             ##
##   We use the coarse mesh generated on the globe and simulate a univariate GP ##
## with zero mean and matern kernal as the true process. Then the observed data ##
## is assumed to be true process plus Gaussian error.                           ##
##   We then infer the true process from the observatiosn by using the MVST     ##
## framework and plot the posterior means and error bars.                       ##
##                                                                              ##
## ***Mesh***                                                                   ##
## * We use the mesh saved in the object MeshGlobe.RData                        ##
##   which was generated by the script Mesh/globe_INLA.R                        ##
##                                                                              ##
## ***Steps***                                                                  ##
## * 0. Initialising and load the previously generated Mesh grid                ##
## * 1. Simulate the true process and observations                              ##
## * 2. Infer the process from observations                                     ##
## * 3. Plot the results and save                                               ##
##################################################################################

#### 0. Set working directory, load data and packages 
setwd("O:/glbm")
load("Mesh/GlobeMesh/MeshGlobe.RData")
library(INLA)
library(rgdal)
library(maptools)
library(GEOmap)
library(rgl)

library(dplyr)
library(ggplot2)
library(MVST)

#### 1. Simulate the true process and observed data 
## Assume the true process follows a GP with zero mean and Matern kernel
## Extract mesh grid points
##mesh.centroid <- function(mesh){
  # get the geometric centroid of the meshed grids
##  total.vertices <- 1:length(mesh$graph$tv[,1])
##  t(sapply(total.vertices, function(x) colMeans(mesh$loc[mesh$graph$tv[x,],])))
##}
##mglb_sc <- mesh.centroid(MeshB) # extract the centroids the cells

### 1.1 Process points = observation points
mglb_tv <- MeshB$loc # extract the triaulation vertices
## Simulate the process based on the veritices
## Now we actually have a dense covariance and precision matrix
mglb_S1 <- Matern(as.matrix(dist(mglb_tv)), nu = 3/2, var = 4, kappa = 0.1) # create the Matern covmat
mglb_Q1 <- GMRF(Q = as(chol2inv(chol(mglb_S1)),"dgCMatrix")) # the precmat
mglb_x1 <- sample_GMRF(mglb_Q1) # simulate the true processs

## Simulate the observations, assume the error is Gaussian with sd = 0.1
sd1 <- 0.1
mglb_y1 <- mglb_x1 + rnorm(length(mglb_x1))*sd1
obs <- Obs(df=data.frame(x = mglb_tv[,1], y = mglb_tv[,2], w = mglb_tv[,3], z = mglb_y1, std = sd1, t = rep(0, nrow(mglb_tv))))



### 1.2 Process ponints != observation points
## sample a few points from the mesh location and add some noises
ll_loc <- do.call(cbind, Lxyz2ll(list(x = mglb_tv[,1], y = mglb_tv[,2], z = mglb_tv[,3])))
newloc <- ll_loc[sample(1:nrow(ll_loc), 1000), ] + matrix(rnorm(2000, 0, 4), ncol = 2, nrow = 1000)
newloc[,1] <- ifelse(abs(newloc[,1]) > 90, sign(newloc[,1])*90, newloc[,1])
newloc[,2] <- ifelse(abs(newloc[,2]) > 180, sign(newloc[,2])*180, newloc[,2])

obsloc <- do.call(cbind, Lll2xyz(lat = newloc[,1], lon = newloc[,2]))
plot3d(obsloc)

## Now we actually have a dense covariance and precision matrix
mglb_S2 <- Matern(as.matrix(dist(obsloc)), nu = 3/2, var = 4, kappa = 0.1) # create the Matern covmat
mglb_Q2 <- GMRF(Q = as(chol2inv(chol(mglb_S2)),"dgCMatrix")) # the precmat
mglb_x2 <- sample_GMRF(mglb_Q2) # simulate the true processs

## Simulate the observations, assume the error is Gaussian with sd = 0.1
sd2 <- 0.1
mglb_y2 <- mglb_x2 + rnorm(length(mglb_x2))*sd2
obs2 <- Obs(df=data.frame(x = obsloc[,1], y = obsloc[,2], w = obsloc[,3], z = mglb_y2, std = sd2, t = rep(0, nrow(obsloc))))

### Sample the true process from these poionts together
#loc_all <- rbind(mglb_tv, obsloc)
#Gcov <- Matern(as.matrix(dist(loc_all)), nu = 3/2, var = 4, kappa = 0.1) # create the Matern covmat
#Gprec <- GMRF(Q = as(chol2inv(chol(Gcov)),"dgCMatrix")) # the precmat
## problem -- easily get ill-conditioned mat!!!
#xtrue <- sample_GMRF(Gprec) # simulate the true processs
#sd <- 0.1
#x.obs <- xtrue + rnorm(length(xtrue))*sd

#obs <- Obs(df=data.frame(x = mglb_tv[,1], y = mglb_tv[,2], w = mglb_tv[,3], z = x.obs[1:6851], std = sd1, t = rep(0, nrow(mglb_tv))))
#obs2 <- Obs(df=data.frame(x = obsloc[,1], y = obsloc[,2], w = obsloc[,3], z = x.obs[6852:7851], std = sd2, t = rep(0, nrow(obsloc))))

### 1.3 observation from a different support
## Define polygons and asign observation values to these polygons

#### 2. Infer the process from the observations
### 2.1 process points = observation points
## 2.1.1 Supply a user-defined Cmat
C1 <- Imat(nrow(mglb_tv))

## 2.1.2 use a GMRF basis and find the Cmat by FindC 
## source the new initFEbasis code first before running the following
## Create the finite element object from the inla mesh
MeshB_fem <- inla.mesh.fem(MeshB, order = 2)
MeshBf <- initFEbasis(p=MeshB$loc,
                      t=MeshB$graph$tv,
                      M=MeshB_fem$c1,
                      K=MeshB_fem$g1)
mglb_p <- GMRF_basis(mglb_Q1, Basis = MeshBf)

## Build the LinkGo obj
L1 <- link(mglb_p, obs)  # build from process
L1c <- link(mglb_Q1, obs, Cmat = C1) #build by supplying Cmat

## Do inference
e <- new("link_list",list(L1))
v <- new("block_list",list(G1 = mglb_Q1, O = obs))
G <- new("Graph",e = e,v = v)
G_reduced <- compress(G)
Results1 <- Infer(G_reduced)

## extract posterior results
mglb_x1_post <- Results1$Post_GMRF@rep
x1_mpost<- mglb_x1_post$x_mean
## Get the posterior mean and variance
x1_spost <- sqrt(mglb_x1_post$x_margvar)


### 2.2 process points != observation points
## Find the Cmat by using the inla function
C2 <- inla.spde.make.A(mesh = MeshB, loc = obsloc)
L2 <- link(mglb_Q1, obs2, Cmat = C2)
e2 <- new("link_list",list(L2))
v2 <- new("block_list",list(G1 = mglb_Q1, O = obs2))
G2 <- new("Graph",e = e2,v = v2)
G_reduced <- compress(G2)
Results2 <- Infer(G_reduced)

mglb_x2_post <- Results2$Post_GMRF@rep
x2_mpost<- mglb_x2_post$x_mean
## Get the posterior mean and variance
x2_spost <- sqrt(mglb_x2_post$x_margvar)

#### 3. Plot the result and save

### 3.1 Process points = observations
## 3.1.1 True Process vs Observations
clims <- range(c(mglb_x1, mglb_y1, x1_mpost))
clens <- round((clims[2] - clims[1])*100) + 1
colpal <- terrain.colors(clens, alpha=0)
colx1 <- colpal[round((mglb_x1 - clims[1])*100) + 1]
coly1 <- colpal[round((mglb_y1 - clims[1])*100) + 1]
colxp1 <- colpal[round((x1_mpost - clims[1])*100) + 1]
open3d()
par3d(windowRect = c(100, 100, 1800, 900))
layout3d(matrix(1:4, 2,2), heights = c(8,2), sharedMouse = TRUE)

par3d(zoom = 0.8)
plot3d(mglb_tv,  col = colx1, cex = 2, xlab = "", ylab = "", zlab = "", axe=FALSE) # plot the vertices
plot(MeshB, rgl = TRUE, col = colx1, edge.color = rgb(0, 0.5, 0.6, alpha =0.1), add = TRUE) # add the triangulation

next3d(reuse = FALSE)
bgplot3d({z=matrix(1:clens, nrow = clens)
y=1
x=seq(clims[1],clims[2],len = clens)
par(cex = 1.5, fin = c(8, 1), mai = c(0,0, 0.5, 0), oma = c(1, 0, 0, 0))
image(x,y,z,col = terrain.colors(clens),axes=FALSE,xlab="",ylab="")
title("The true process")
axis(1)})

next3d(reuse = FALSE)
par3d(zoom=0.8)

plot3d(mglb_tv,  col = coly1, cex = 2, xlab = "", ylab = "", zlab = "", axe=FALSE) # plot the vertices
plot(MeshB, rgl = TRUE, col = coly1, edge.color = rgb(0, 0.5, 0.6, alpha =0.1), add = TRUE) # add the triangulation

next3d(reuse = FALSE)
bgplot3d({z=matrix(1:clens,nrow = clens)
y=1
x=seq(clims[1],clims[2],len = clens)
par(cex = 1.5, fin = c(8, 1), mai = c(0,0, 0.5, 0), oma = c(1, 0, 0, 0))
image(x,y,z,col = terrain.colors(clens), axes = FALSE,xlab = "",ylab = "")
title("Observed values")
axis(1)})

writeWebGL(filename= "PvsObs1.html", width = 1500, reuse = TRUE) # save the plot as an html

climss <- round(range(x1_spost*20000))
clenss <- climss[2] - climss[1] + 1
colpals <- heat.colors(clenss, alpha=0)
colsp <- colpals[round(x1_spost*20000) - climss[1]+1]

## 3.1.2 Posterior Means and marginal variances
open3d()
par3d(windowRect = c(100, 100, 1800, 900))
layout3d(matrix(1:4, 2,2), heights = c(8,2), sharedMouse = TRUE)
## The posterior mean
par3d(zoom = 0.8)
plot3d(mglb_tv,  col = colxp1, cex = 2, xlab = "", ylab = "", zlab = "", axe=FALSE) # plot the vertices
plot(MeshB, rgl = TRUE, col = colxp1, edge.color = rgb(0, 0.5, 0.6, alpha =0.1), add = TRUE) # add the triangulation

next3d(reuse = FALSE)
bgplot3d({z=matrix(1:clens,nrow = clens)
y=1
x=seq(clims[1],clims[2],len = clens)
par(cex = 1.5, fin = c(8, 1), mai = c(0,0, 0.5, 0), oma = c(1, 0, 0, 0))
image(x,y,z,col=terrain.colors(clens),axes=FALSE,xlab="",ylab="")
title("Posterior mean")
axis(1)})


next3d(reuse = FALSE)
par3d(zoom=0.8)
## The posterior marginal std
plot3d(mglb_tv,  col = colsp, cex = 2, xlab = "", ylab = "", zlab = "", axe=FALSE) # plot the vertices
plot(MeshB, rgl = TRUE, col = colsp, edge.color = rgb(0, 0.5, 0.6, alpha =0.1), add = TRUE) # add the triangulation

next3d(reuse = FALSE)
bgplot3d({z=matrix(1:148,nrow=148)
y=1
x=seq(min(x1_spost),max(x1_spost),len=148)
par(cex = 1.5, fin = c(8, 1), mai = c(0,0, 0.5, 0), oma = c(1, 0, 0, 0))
image(x,y,z,col=heat.colors(148),axes=FALSE,xlab="",ylab="")
title("Posterior standard error")
axis(1)})

writeWebGL(filename= "posterior1.html", width = 1500, reuse = TRUE)

### 3.2 Process points != observations
## 3.2.1 True Process vs Observations
clims <- range(c(mglb_x2, mglb_y2, x2_mpost))
clens <- round((clims[2] - clims[1])*100) + 1
colpal <- terrain.colors(clens, alpha=0)
colx2 <- colpal[round((mglb_x2 - clims[1])*100) + 1]
coly2 <- colpal[round((mglb_y2 - clims[1])*100) + 1]
colxp2 <- colpal[round((x2_mpost - clims[1])*100) + 1]
open3d()
par3d(windowRect = c(100, 100, 1800, 900))
layout3d(matrix(1:4, 2,2), heights = c(8,2), sharedMouse = TRUE)

par3d(zoom = 0.8)
plot3d(obsloc,  col = colx2, cex = 2, xlab = "", ylab = "", zlab = "", axe=FALSE) # plot the vertices
plot(MeshB, rgl = TRUE, edge.color = rgb(0, 0.5, 0.6, alpha =0.1), add = TRUE) # add the triangulation

next3d(reuse = FALSE)
bgplot3d({z=matrix(1:clens, nrow = clens)
y=1
x=seq(clims[1],clims[2],len = clens)
par(cex = 1.5, fin = c(8, 1), mai = c(0,0, 0.5, 0), oma = c(1, 0, 0, 0))
image(x,y,z,col = terrain.colors(clens),axes=FALSE,xlab="",ylab="")
title("The true process")
axis(1)})

next3d(reuse = FALSE)
par3d(zoom=0.8)
plot3d(obsloc,  col = coly2, cex = 2, xlab = "", ylab = "", zlab = "", axe=FALSE) # plot the vertices
plot(MeshB, rgl = TRUE, edge.color = rgb(0, 0.5, 0.6, alpha =0.1), add = TRUE) # add the triangulation

next3d(reuse = FALSE)
bgplot3d({z=matrix(1:clens,nrow = clens)
y=1
x=seq(clims[1],clims[2],len = clens)
par(cex = 1.5, fin = c(8, 1), mai = c(0,0, 0.5, 0), oma = c(1, 0, 0, 0))
image(x,y,z,col = terrain.colors(clens), axes = FALSE,xlab = "",ylab = "")
title("Observed values")
axis(1)})

writeWebGL(filename= "PvsObs2.html", width = 1500, reuse = TRUE)

climss <- round(range(x2_spost*20000))
clenss <- climss[2] - climss[1] + 1
colpals <- heat.colors(clenss, alpha=0)
colsp2 <- colpals[round(x2_spost*20000) - climss[1]+1]

## 3.2.2 Posterior Means and marginal variances
open3d()
par3d(windowRect = c(100, 100, 1800, 900))
layout3d(matrix(1:4, 2,2), heights = c(8,2), sharedMouse = TRUE)
## The posterior mean
par3d(zoom = 0.8)
plot3d(obsloc,  col = colx2, cex = 2, xlab = "", ylab = "", zlab = "", axe=FALSE) # plot the vertices
plot(MeshB, rgl = TRUE, col = colxp2, edge.color = rgb(0, 0.5, 0.6, alpha =0.1), add = TRUE) # add the triangulation

next3d(reuse = FALSE)
bgplot3d({z=matrix(1:clens,nrow = clens)
y=1
x=seq(clims[1],clims[2],len = clens)
par(cex = 1.5, fin = c(8, 1), mai = c(0,0, 0.5, 0), oma = c(1, 0, 0, 0))
image(x,y,z,col=terrain.colors(clens),axes=FALSE,xlab="",ylab="")
title("Posterior mean")
axis(1)})


next3d(reuse = FALSE)
par3d(zoom=0.8)
## The posterior marginal std
plot3d(obsloc, cex = 2, xlab = "", ylab = "", zlab = "", axe=FALSE) # plot the vertices
plot(MeshB, rgl = TRUE, col = colsp2, edge.color = rgb(0, 0.5, 0.6, alpha =0.1), add = TRUE) # add the triangulation

next3d(reuse = FALSE)
bgplot3d({z=matrix(1:clenss,nrow=clenss)
y=1
x=seq(min(x2_spost),max(x2_spost),len=clenss)
par(cex = 1.5, fin = c(8, 1), mai = c(0,0, 0.5, 0), oma = c(1, 0, 0, 0))
image(x,y,z,col=heat.colors(clenss),axes=FALSE,xlab="",ylab="")
title("Posterior standard error")
axis(1)})

writeWebGL(filename= "posterior2.html", width = 1500, reuse = TRUE)
