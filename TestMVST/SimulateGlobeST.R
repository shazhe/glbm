##################################################################################
##                 Test script for simulate and estimate                        ## 
##           a univariate spatio-temporal process on the globe                  ## 
##   We use the coarse mesh generated on the globe and simulate a univariate GP ##
## with zero mean and matern kernal as the true process. Then the observed data ##
## is assumed to be true process plus Gaussian error.                           ##
##   In this test script, we also add a linear time trend and auto-regressive   ##
## in the time covariance structure.                                            ##
##   We then infer the true process from the observatiosn by using the MVST     ##
## framework and plot the posterior means and error bars.                       ##
##                                                                              ##
## ***Mesh***                                                                   ##
## * We use the mesh saved in the object MeshGlobe.RData                        ##
##   which was generated by the script Mesh/globe_INLA.R                        ##
##                                                                              ##
## ***Steps***                                                                  ##
## * 0. Initialising and load the previously generated Mesh grid                ##
## * 1. Simulate the true process and observations                              ##
## * 2. Infer the process from observations                                     ##
## * 3. Plot the results and save                                               ##
##################################################################################

#### 0. Set working directory, load data and packages 
setwd("O:/globalmass_code")
load("Mesh/GlobeMesh/MeshGlobe.RData")
library(INLA)
library(rgdal)
library(maptools)
library(GEOmap)
library(rgl)

library(dplyr)
library(ggplot2)
library(MVST)


#### 1. Simulate the true process and observed data 

### 1.1 The true process
## Assume the following true process
## x(t+1;s) = mu(t;s) + A(t)x(t;s) + Beta_0(s) + tBeta_1(s) + e(t;s) 
## where we set
## mu(t;s) = 0
## A(t) = A = 0.2*I_n 
## Beta_0(s) and Beta_1(s) are spatial varying coefficients
## e(t;s) GP with zero mean and Matern kernel -- independent in time

## Extract mesh grid points
mglb_tv <- MeshB$loc # extract the triaulation vertices
n.v <- nrow(mglb_tv)

## A -- the auto-regressive operator for time -- independent in space
A <- 0.2*diag(n.v)

## Beta -- from an iid normal prior
Beta0 <- rnorm(n.v)*0.1 + 1 # mean intercept = 1
Beta1 <- rnorm(n.v)*0.05 + 0.1 # mean slope = 0.1

## e(t;s) -- the error for t = 0:6
e.cov <- Matern(as.matrix(dist(mglb_tv)), nu = 3/2, var = 4, kappa = 1) # create the Matern covmat
e.prec <- GMRF(Q=as(chol2inv(chol(e.cov)),"dgCMatrix")) # the precmat
e.all <- replicate(7, sample_GMRF(e.prec)) # simulate the true processs

## simulate the true process by time
x.all <- Beta0 + Beta1 %*% matrix(0:6, 1,7) + e.all
for (i in 2:7){
  x.all[,i] <- x.all[,i] + A%*%x.all[,i-1]
}

## Plot the true process and observations at year 0 and year 6
open3d()
par3d(windowRect = c(100, 100, 1800, 900))
layout3d(matrix(1:4, 2,2), heights = c(8,2), sharedMouse = TRUE)
## Year 0
par3d(zoom = 0.8)
clims <- range(c(x.all[,1]))
clens <- round((clims[2] - clims[1])*50) +1
colpal <- terrain.colors(clens, alpha=0)
colx <- colpal[round((x.all[,1] - clims[1])*50)+1]
plot3d(mglb_tv,  col = colx, cex = 2, xlab = "", ylab = "", zlab = "", axe=FALSE)
plot(MeshB, rgl = TRUE, col = colx, edge.color = rgb(0, 0.5, 0.6, alpha =0.1),add = TRUE)

next3d(reuse = FALSE)
bgplot3d({z=matrix(1:clens,nrow=clens)
y=1
x=seq(clims[1],clims[2],len=clens)
par(cex = 1.5, fin = c(8, 1), mai = c(0,0, 0.5, 0), oma = c(1, 0, 0, 0))
image(x,y,z,col=terrain.colors(clens),axes=FALSE,xlab="",ylab="")
title("Year 0")
axis(1)})

## Year 6
next3d(reuse = FALSE)
par3d(zoom = 0.8)
clims <- range(c(x.all[,7]))
clens <- round((clims[2] - clims[1])*50) +1
colpal <- terrain.colors(clens, alpha=0)
colx <- colpal[round((x.all[,7] - clims[1])*50)+1]
plot3d(mglb_tv,  col = colx, cex = 2, xlab = "", ylab = "", zlab = "", axe=FALSE)
plot(MeshB, rgl = TRUE, col = colx, edge.color = rgb(0, 0.5, 0.6, alpha =0.1),add = TRUE)

next3d(reuse = FALSE)
bgplot3d({z=matrix(1:clens,nrow=clens)
y=1
x=seq(clims[1],clims[2],len=clens)
par(cex = 1.5, fin = c(8, 1), mai = c(0,0, 0.5, 0), oma = c(1, 0, 0, 0))
image(x,y,z,col=terrain.colors(clens),axes=FALSE,xlab="",ylab="")
title("Year 7")
axis(1)})

### 1.2 The Observations -- assume adding iid normal error with sd = 0.1
sd1 <- 0.1
x.obs <- x.all + matrix(rnorm(n.v*7)*sd1, nrow = n.v, ncol = 7)

## Plot the observatons in Year 6
clims <- range(c(x.all[,7], x.obs[,7]))
clens <- round((clims[2] - clims[1])*50) +1
colpal <- terrain.colors(clens, alpha=0)
col.obs <- colpal[round((x.obs[,7] - clims[1])*50) + 1]
plot(MeshB, rgl = TRUE, col = col.obs, edge.color = rgb(0, 0.5, 0.6, alpha =0.1))
plot3d(mglb_tv, add = TRUE, col = coly, cex = 2) # add the coastlines points



#### 2. Infer the process from the observations
## Create the observation object
obs0 <- data.frame(x=mglb_tv[,1], y = mglb_tv[,2], w = mglb_tv[,3], z=x.obs[,1], std=sd1)
obs_df <- do.call(rbind, lapply(1:7, function(x) 
  data.frame(x=mglb_tv[,1], y = mglb_tv[,2], w = mglb_tv[,3], z=x.obs[,x], std=sd1, t = x-1)))
Xobs <- Obs(df=obs_df,name="Xobs")

## Create the GMRF basis for the spatial temporal auto-regressive processes
## Create the finite element object from the inla mesh
MeshB_inla_fem <- inla.mesh.fem(MeshB, order = 2)
MeshB_fem <- list(p = MeshB$loc , t = MeshB$graph$tt, M = MeshB_inla_fem$c1, K = MeshB_inla_fem$g1)
md5_wrapper <- md5_cache("~/cache/")
MeshBf <- md5_wrapper(initFEbasis,p=MeshB_fem$p,
                    t=MeshB_fem$t,
                    M=MeshB_fem$M,
                    K=MeshB_fem$K)

## We assumed mean = 0 for mu
mu <- function(k) { # time-varying matrix for mu
  return(matrix(0,nrow(MeshBf),1))
}


## We A as the auto-regressive operator which does not interact with space at a given time
A <- function(k) {# time-varying matrix for A
  0.2*Imat(nrow(MeshBf))
}

Q <- function(k) { # time-varying matrix for Q
  Prec_from_SPDE_wrapper(M = mass_matrix(MeshBf),
                         K = stiffness_matrix(MeshBf),
                         nu = 1,
                         desired_prec = 1,
                         l = 1200)
}
  
t_axis = 0:6
Xtrue_VAR <- VAR_Gauss( mu = mu, A=A, Qw = Q, t_axis = t_axis, name="Xtrue")

Xtrue <- GMRF_basis(G = Xtrue_VAR, Basis = MeshBf)
L1 <- MVST:::link(Xtrue, Xobs, Cmat = Imat(nrow(Xobs)))


L1 <- new("linkGO", from = Xtrue, to = Xobs,  md5_wrapper = md5_wrapper)


e <- new("link_list",list(L1))
v <- new("block_list",list(G1=Xtrue, O=Xobs))
G <- new("Graph",e=e,v=v)
G_reduced <- compress(G)
Results <- Infer(G_reduced)


## Get the posterior mean and variance
mglb_x1_post <- Results$Post_GMRF@rep
x1_mpost<- mglb_x1_post$x_mean
x1_spost <- sqrt(mglb_x1_post$x_margvar)

## Plot the posterior results
colxp <- colpal[round((x1_mpost - min(x1_mpost))*100)+1]
plot(MeshB, rgl = TRUE, col = colxp, edge.color = rgb(0, 0.5, 0.6, alpha =0.1))
plot3d(mglb_tv, add = TRUE, col = colxp, cex = 2) # add the coastlines points

climss <- round(range(x1_spost*20000))
clenss <- climss[2] - climss[1] +1
colpals <- heat.colors(clenss, alpha=0)
colsp <- colpals[round(x1_spost*20000) - climss[1]+1]
