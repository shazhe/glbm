---
title: "Experiment 2a"
author: "Z Sha"
date: "22 November 2017"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In this experiment, we assume the GIA is known so there will be only two independent latent process $X_{ssh}$ and $X_{mass}$ and the third one $X_{steric}$ is given by $X_{steric} = X_{ssh} - x_{GIA} - X_{mass}$. Given the altimetry and GRACE data, the $X_{steric}$ can be predicted as an linear combination of posterior ssh and mass change:
$$X_{steric} |  Y_{alt}, Y_{GRACE} = X_{ssh} | Y_{alt} - X_{mass}|Y_{GRACE} - x_{GIA}$$

Therefore, in the following we use the same approach as in Experiment 1 to obtain the updated $X_ssh$ and $X_{mass}$. In this first experiment we assume these two process can be updated independently. 

```{r loadlibs, message = FALSE, warning = FALSE}
library(rgdal); library(sp);library(GEOmap)
library(INLA)
source("C:/ZSwork/glbm/BHM_sphere/functions.R")
source("C:/ZSwork/glbm/BHM_sphere/partition_fun.R")
```

# Update $X_{ssh}$

First we load the altimetry data and do some exploratory analysis on the spatial property of the process.

## Load data 

Load the pre-processed altimetry data. The data are the yearly trend estimates over 10 years (2005-2015) and their estimated errors at one degree resolution.
```{r alt_data}
library(ncdf4)
alt_nc <- nc_open("Z:/WP3-Ocean/BHMinputs/SSH/trend_SSH_CCI_200501_201512.nc")
print(alt_nc)
lon <- ncvar_get(alt_nc, "lon")
lat <- ncvar_get(alt_nc, "lat")
trend_ssh <- ncvar_get(alt_nc, "trend_ssh") #note that there re NAs for land datat
err_ssh <- ncvar_get(alt_nc, "err")

alt_data <- data.frame(trend_ssh = as.numeric(trend_ssh), err_ssh = as.numeric(err_ssh))
alt_data$lon <- rep(lon, 180) 
alt_data$lat <- rep(lat, each = 360)
alt_data2 <- na.omit(alt_data)
## Find the xyz coords of the altimetry data
alt_loc <- do.call(cbind, Lll2xyz(lon = alt_data2$lon, lat = alt_data2$lat))
## plot the data
lattice::levelplot(trend_ssh ~ lon + lat, data = alt_data2, aspect = "iso",  at =seq(-20, 20, 4),
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")

lattice::levelplot(err_ssh ~ lon + lat, data = alt_data2, aspect = "iso",  at = seq(0, 4, 0.5),
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")
```

## prior set up

Now we do some exploratory analysis which will be helpful in setting up the prior for hyper parameters $\rho$ and $\sigma^2$ for the SSH process. We can set up a vague prior in this preliminary study and later on set the prior to be concentrated if more information of ssh is given. We learn a sensible value for a initial mean by plotting the variogram of the the altimetry data.

The following chunk plot the smoothed variogram of the altimerty trend. It takes a long time to run due to the size of the data.

```{r variogram, message = FALSE}
library(gstat)
coordinates(alt_data2) <- c("lon", "lat")
proj4string(alt_data2) <- CRS("+proj=longlat")
alt_datas <- alt_data2[sample(1:nrow(alt_data2), 5000),] # thin the data otherwise it takes too long! plot remains the same
v1 <- variogram(trend_ssh ~ 1, alt_datas) 
plot(v1)
```

From the variogram plot, it seems the correlation length is about 3000km and the variance can be as high as 25. Hence we set the prior mean of $\rho$ to $3000/6371 \approx 0.47$ and $\sigma= 5$.
```{r prior}
## Priors mean and variance for the parameters: rho and sigma
mu_r <- 3000/6371
v_r <- 1
mu_s <- 5
v_s <- 10^2
```

The sea surface height is only defined on oceans so we will model this process only on the ocean. The following chunk load the low resolution global ocean polygons from NatureEarth and generate mesh with equal area triangles of approximately one degree resolution.

## Generate mesh 

To build the spde model used for approximating the process, we need to generate a triangular mesh for the process. In general, the triangles in the mesh should have similar size and shape and the size of the triangles should be no larger than the spatial correlation length. 

In our exploratory analysis, the correlation length is quite long, therefore if the purpose is estimating the hyper-parameters, then we can choose to have a sparse mesh with resolution no large than the correlation length. Here we could use say a triangle size to have approximately 5 degree resolution so that the edge length of the triangles are smaller than 500km on average which is much smaller than 3000km. 

However, Since our purpose is to produce a map of the process at high resolution, we must have a mesh with at least the desired prediction resolution. For a 1 degree resolution map, we will need about $360 \times 180 = 64800$ triangles corresponding to number of vertices of $v \approx  (f+2)*2/5= 25921$. When using the Fibonacci grid points in long lat coordinates as the starting points for generating the mesh, the number of points is about half of the triangle vertices.

```{r ssh_mesh}
## Genereate Fibonacci points on the sphere
fibo_points <- fiboSphere(N = 12960, L0 = TRUE)
fibo_points_xyz <- do.call(cbind, Lll2xyz(lat = fibo_points[,2], lon = fibo_points[,1]))
mesh0 <- inla.mesh.2d(loc = fibo_points_xyz, cutoff = 0.01, max.edge = 1)
## Make this "smoother"
mesh0 <- inla.mesh.2d(loc = mesh0$loc, cutoff = 0.01, max.edge = 1)
```

Since the process is only defined on the ocean, we remove the mesh that are not in the modelling region. And to make sure the triangles capture the shape of the coastlines, we add extra points near the coastlines.
```{r ssh_mesh2}
## Load the Ocean polygon
Ocean <- readOGR(dsn = "Z:/WP1-BHM/maps/ne_110m_ocean", layer = "ne_110m_ocean")
plot(Ocean)

## Remove mesh not in the ocean
mesh0 <- dt.mesh.addon.posTri(mesh = mesh0, globe = TRUE) 
Tlonlat <- Lxyz2ll(list(x = mesh0$posTri[,1], y = mesh0$posTri[,2], z = mesh0$posTri[,3]))
mesh0$Trill <- cbind(lon = Tlonlat$lon, lat =Tlonlat$lat)
TinOcean <- unlist(over(Ocean, SpatialPoints(coords=mesh0$Trill, proj4string = CRS(proj4string(Ocean))), returnList=T))
TAll <- 1:mesh0$t
ToutOcean <- TAll[-TinOcean]
Omega = dt.Omega(list(TinOcean, 1:mesh0$t), mesh0)

mesh_ssh <- mesh.sub(mesh0, Omega, 1)
summary(mesh_ssh)
```




```{r spde}
## Transform the parameters for the SPDE_GMRF approximation
trho <- Tlognorm(mu_r, v_r)
tsigma <- Tlognorm(mu_s, v_s)

## Build the SPDE model with the prior
lsigma0 <- tsigma[1]
theta1_s <- tsigma[2]
lrho0 <- trho[1]
theta2_s <- trho[2]
lkappa0 <- log(8)/2 - lrho0
ltau0 <- 0.5*log(1/(4*pi)) - lsigma0 - lkappa0

SSH_spde <- inla.spde2.matern(mesh_ssh, B.tau = matrix(c(ltau0, -1, 1),1,3), B.kappa = matrix(c(lkappa0, 0, -1), 1,3),
                              theta.prior.mean = c(0,0), theta.prior.prec = c(sqrt(1/theta1_s), sqrt(1/theta2_s)))

```





## Link data to process

Now we link the data to the process. The altimetry data is gridded with 1 degree resolution and we have a mesh with about the same resolution, so we can simply use a point to point identity map to link the data to the process: each data point observe the process from the same location.

```{r link_data}
## Link the process to observations and predictions
A_data <- inla.spde.make.A(mesh = mesh_ssh, loc = alt_loc)
A_pred <- inla.spde.make.A(mesh = mesh_ssh, loc = rbind(mesh_ssh$loc))

## Create the estimation and prediction stack
st.est <- inla.stack(data = list(y=alt_data2$trend_ssh), A = list(A_data),
                     effects = list(SSH = 1:SSH_spde$n.spde), tag = "est")
st.pred <- inla.stack(data = list(y=NA), A = list(A_pred),
                      effects = list(SSH=1:SSH_spde$n.spde), tag = "pred")
stSSH <- inla.stack(st.est, st.pred)
```

## INLA inference

Now we can run INLA for the Bayesian inference. Do not run on a desktop the process may use up to 64GB memory at peak. We ran this on a server with enough memory.

```{r inla_run, include = TRUE, eval = FALSE}
## Fix altimetry errors as they are known
hyper <- list(prec = list(fixed = TRUE, initial = 0))
prec_scale <- c(1/alt_data2$err_ssh^2, rep(1, nrow(A_pred)))

## The formular for modelling the SSH mean
formula = y ~ -1 +  f(SSH, model = SSH_spde)

## Run INLA
res_inla <- inla(formula, data = inla.stack.data(stSSH, spde = SSH_spde), family = "gaussian",
                 scale =prec_scale, control.family = list(hyper = hyper),
                 control.predictor=list(A=inla.stack.A(stSSH), compute =TRUE))
```

## Results

### Assemble and save results

Now assemble the inla inference and prediction results.
```{r inla_res, include = TRUE, eval = FALSE}
INLA_pred <- res_inla$summary.linear.predictor
## Extract and project predictions
pred_idx <- inla.stack.index(stSSH, tag = "pred")$data

## SSH
SSH_m <- INLA_pred$mean[pred_idx] 
SSH_u <- INLA_pred$sd[pred_idx]
proj <- inla.mesh.projector(mesh_ssh, projection = "longlat", dims = c(360,180), xlim = c(0,359), ylim = c(-89.5, 89.5))
SSH_grid <- expand.grid(proj$x, proj$y)
SSH_pred <- data.frame(lon = SSH_grid[,1], lat = SSH_grid[,2],
                       mean = as.vector(inla.mesh.project(proj, as.vector(SSH_m))),
                       u = as.vector(inla.mesh.project(proj, as.vector(SSH_u))))

res_SSH <- list(res_inla = res_inla, spde = SSH_spde, st = stSSH, 
            mesh = mesh_ssh,  SSH_pred = SSH_pred)

save(res_SSH, file ="Z:/WP1-BHM/Experiment2a/exp2a_ssh.RData")
```


### Plot the posteriors of the hyper parameters

```{r hyper, include=TRUE}
load("Z:/WP1-BHM/Experiment2a/exp2a_ssh.RData")
pars_SSH <- marginal_par(res = res_SSH, process = "SSH", plot = TRUE)
## The posterior modes
print(paste("The estimated correlation lengths are:", pars_SSH$rho_mode*6371,  sep = "  "))

print(paste("The estimated marginal variances are:", pars_SSH$sigma_mode,sep = "  "))
```


## Plot the predictions

In this experiment, it is more convenient to produce the prediction at the altimetry data directly, since they are grid points.
We plot the predicted SSH at these locations and compare them to the altimetry data
```{r predict, include=TRUE}
alt_pred <- res_SSH$SSH_pred
alt_pred$source1 <- "SSH predicted mean"
alt_pred$source2 <- "SSH predicted uncertainty"
alt_data$source1 <- "Altimetry trend"
alt_data$source2 <- "Altimetry error"
names(alt_data)[1:2] <- c("mean", "u") 
alt_diff <- data.frame(lon = alt_pred$lon, lat = alt_pred$lat, diff = alt_pred$mean-alt_data$mean)
alt_pred <- rbind(alt_pred, alt_data)


## plot the mean 
lattice::levelplot(mean ~ lon + lat | source1, data = alt_pred, aspect = "iso", at = seq(-20, 20, 2),
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")

## plot the uncertainty
lattice::levelplot(u ~ lon + lat | source2, data = alt_pred, aspect = "iso", at = seq(0, 3, 0.5),
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")

## Plot the differnce
lattice::levelplot(diff ~ lon + lat, data = alt_diff, aspect = "iso", at = seq(-20, 20, 2),
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")
```





# Update $X_{mass}$

Now we do the same thing for the mass change process.

## Load data 

Load the Grace mascon data.
```{r grace_data}
grace_data <- read.table("Z:/WP2-SolidEarth/BHMinputs/GRACE/GRACE_v02.3b_trends_v03.txt", header = T)
grace_loc <-  read.table("Z:/WP2-SolidEarth/BHMinputs/GRACE/GRACE_v02.3b_loc_v03.txt", skip = 1)
n_grace <- ncol(grace_loc)
n_ll <- (n_grace-4)/2
names(grace_loc) <- c("id", "area", "lon_c", "lat_c", paste0(c("lon", "lat"), rep(1:n_ll, each = 2)))

## Create spatial polygons data frame
Polygon_list <- list()
for(i in 1:nrow(grace_loc)){
  lons <- na.omit(as.numeric(c(grace_loc[i, seq(5,ncol(grace_loc), 2)], grace_loc[i, 5])))
  lats <- na.omit(as.numeric(c(grace_loc[i, seq(6,ncol(grace_loc), 2)], grace_loc[i, 6])))
  Polygon_list[[i]] <- Polygon(cbind(lons, lats))
}

Polygons_list <- lapply(1:length(Polygon_list), function(x) Polygons(list(Polygon_list[[x]]), x))
SpPolygon <- SpatialPolygons(Polygons_list, proj4string = CRS("+proj=longlat"))

grace_sp <- SpatialPolygonsDataFrame(SpPolygon,grace_data)
grace_sp$mmweq2 <- ifelse(abs(grace_sp$mmweq) > 20, sign(grace_sp$mmweq)*20, grace_sp$mmweq )
spplot(grace_sp, "mmweq2", at = seq(-21, 21, 2))

## note the area calcuated by R is different from those given in the dataset -- ask Maike
```

## prior set up

Use the polygon data to have rough estimate of the correlation length and variance.
```{r Grace_prior}
grace_v <- data.frame(mean = grace_data$mmweq, lon = grace_loc$lon_c, lat = grace_loc$lat_c)
coordinates(grace_v) <- c("lon", "lat")
proj4string(grace_v) <- CRS("+proj=longlat")
v2 <- variogram(mean~1, grace_v) 
plot(v2)

## Priors mean and variance for the parameters: rho and sigma
mu_r <- 2000/6371
v_r <- 1
mu_s <- 2
v_s <- 5^2

## Transform the parameters for the SPDE_GMRF approximation
trho <- Tlognorm(mu_r, v_r)
tsigma <- Tlognorm(mu_s, v_s)

## Build the SPDE model with the prior
lsigma0 <- tsigma[1]
theta1_s <- tsigma[2]
lrho0 <- trho[1]
theta2_s <- trho[2]
lkappa0 <- log(8)/2 - lrho0
ltau0 <- 0.5*log(1/(4*pi)) - lsigma0 - lkappa0

mass_spde <- inla.spde2.matern(mesh0, B.tau = matrix(c(ltau0, -1, 1),1,3), B.kappa = matrix(c(lkappa0, 0, -1), 1,3),
                              theta.prior.mean = c(0,0), theta.prior.prec = c(sqrt(1/theta1_s), sqrt(1/theta2_s)))

```


## Generate mesh 

We also need a mesh to represent the mass process. For the same reason as discussed in previous section for SSH, we need a mesh with 1 degree resolution. The GRACE data is all over the globe, so we can use the \code{mesh0}.

## Link data to process

The GRACE data we have are mass anomalies aggregated into large polygon grid and we call them "super mascons" as they are on larger grid than the original data provided by the GRACE project. To link the data to the process, we need to integrate the process value over the corresponding polygon. The integration can be done numerically as weighted sum of the grid values within the polygons. The grid values are represented by the GMRF.

A most tricky setting is the scaling factor! Since the projection matrix A approximate map inputs to outputs on different scales, this can make the computation unstable when the difference in the scales are huge. The scale also determines the scale of the marginal variance and predicted uncertainties. 

We choose to scale the prediction by $1e4$ for a $100km \times 100km$ area resolution. This approximately correspond to a 1 degree resolution and also at the similar scale of the GRACE data polygon size.
```{r grace_link, eval = FALSE}
## For each polygon observation we generate the regular spaced grid and the number of grid cell is proportional to the area of the polygon
grace_area <- geosphere::areaPolygon(grace_sp)/(1000^2)
plot(grace_loc$area, grace_area)
abline(a = 0, b =1)
grace_sp$area <-grace_area
area_mean <- mean(grace_area)
#spplot(grace_sp, "area")

## Generate the integration grid for each polygons
poly_block <- function(i, dis = 10){
  sp_i <- SpatialPolygons(list(grace_sp@polygons[[i]]), proj4string=CRS("+proj=longlat"))
  area_i <- grace_sp$area[i]
  grid_i <- spsample(sp_i, n = round(area_i/dis^2), type = "regular", offset=c(0.5, 0.5))
  ngrid_i <- length(grid_i)
  grid_xyz <- do.call(cbind, Lll2xyz(lat = grid_i@coords[,2], lon = grid_i@coords[,1]))
  block_i <- rep(i, ngrid_i) 
  weights <- rep(area_i/ngrid_i, ngrid_i)
  return(list(grid_xyz = grid_xyz, block = block_i, weights = weights, ngrid = ngrid_i))
}

grace_block <- lapply(1:nrow(grace_sp), poly_block, dis = 10)

grid_xyz <- do.call(rbind, lapply(grace_block, "[[", "grid_xyz"))
grid_block <- do.call(c, lapply(grace_block, "[[", "block"))
weights <- do.call(c, lapply(grace_block, "[[", "weights"))

A_GRACE_data <- inla.spde.make.A(mesh = mesh0, loc = grid_xyz, block = grid_block,  weights = weights)
```

The GRACE data also see the contribution of GIA. In this experiment, we assume GIA is known so we can remove the GIA contribution to GRACE.

First load the GIA data. We use the ICE-6G data and use the same mesh grid as $mass$ to reprensent GIA.
```{r gia_data, eval = FALSE}
ice6g <- read.table("Z:/WP2-SolidEarth/BHMinputs/GIA/GIA_Pel-6-VM5_ewh.txt", header = T)
ice6g$x_center <- ifelse(ice6g$x_center < 0, ice6g$x_center+360, ice6g$x_center)
ice6g2<- ice6g[order(ice6g$y_center,ice6g$x_center ),]
gia_loc <- do.call(cbind, Lll2xyz(lat = ice6g2$y_center, lon = ice6g2$x_center))

polycoords <- ice6g2[,c(6:13, 6,7)] 
plist <- lapply(ice6g2$ID, 
                function(x) Polygons(list(Polygon(cbind(lon = as.numeric(polycoords[x, c(1,3,5,7,9)]), 
                                                        lat = as.numeric(polycoords[x, c(2,4,6,8,10)])))), ID = x))
Plist <- SpatialPolygons(plist, proj4string = CRS("+proj=longlat"))
gia_area <- geosphere::areaPolygon(Plist)/(1000^2)
meshLL <- Lxyz2ll(list(x=mesh0$loc[,1], y = mesh0$loc[,2], z = mesh0$loc[,3]))
mesh_sp <- SpatialPoints(data.frame(lon = meshLL$lon, lat = meshLL$lat), proj4string = CRS("+proj=longlat")) 

mesh_idx <- over(mesh_sp, Plist)
ice6g2$trend2 <- ice6g2$trend/(gia_area)
GIA_v <- ice6g2$trend2[mesh_idx]
```


```{r grace_gia_remove}
GIA_grace <- A_GRACE_data %*% GIA_v
grace_data <- grace_sp$mmweq + GIA_grace
grace_sp@data$gia <- as.numeric(GIA_grace)
grace_sp@data$mass <- as.numeric(grace_data)
spplot(grace_sp, "gia")
spplot(grace_sp, "mass")
```

```{r grace_pred_link}
## Same for prediction on a 1 degree resolution grid, we need to know the area of the grid for integration
## generate the prediction grid
gx <- seq(0, 359, 1)
gy <- seq(-89.5, 89.5)
grid_ll <- expand.grid(gx, gy)
pred_data <- data.frame(lon = grid_ll[,1], lat = grid_ll[,2])
coordinates(pred_data) <-c("lon", "lat")
gridded(pred_data) <- TRUE
pred_data <- as(pred_data, "SpatialPolygons")
proj4string(pred_data) <- CRS("+proj=longlat")
areas <- geosphere::areaPolygon(pred_data)/(1000^2)
grid_pred <- do.call(cbind,Lll2xyz(lat = grid_ll[,2], lon = grid_ll[,1]))
A_mass_pred <- inla.spde.make.A(mesh = mesh0, loc = grid_pred, weights = areas/1e4)

## Create the estimation and prediction stack
st.est <- inla.stack(data = list(y=grace_sp$mass), A = list(A_GRACE_data),
                     effects = list(mass = 1:mass_spde$n.spde), tag = "est")
st.pred <- inla.stack(data = list(y=NA), A = list(rbind(A_GRACE_data, A_mass_pred)),
                      effects = list(mass=1:mass_spde$n.spde), tag = "pred")
stmass <- inla.stack(st.est, st.pred)
```


## INLA inference

Now we can run INLA for the Bayesian inference. Do not run on a desktop the process may use up to 64GB memory at peak. We ran this on a server with enough memory.

```{r inla_run_grace, include = TRUE, eval = FALSE}
## Fix altimetry errors as they are known
hyper <- list(prec = list(fixed = TRUE, initial = 0))
prec_scale <- c(1/grace_sp$std^2, rep(1, nrow(A_mass_pred) + nrow(A_GRACE_data)))

## The formular for modelling the SSH mean
formula = y ~ -1 +  f(mass, model = mass_spde)

## Run INLA
res_inla <- inla(formula, data = inla.stack.data(stmass, spde = mass_spde), family = "gaussian",
                 scale =prec_scale, control.family = list(hyper = hyper),
                 control.predictor=list(A=inla.stack.A(stmass), compute =TRUE))
```


## Results
### Assemble and save results

Now assemble the inla inference and prediction results.
```{r inla_res_grace, include = TRUE, eval = FALSE}
INLA_pred <- res_inla$summary.linear.predictor
## Extract and project predictions
pred_idx <- inla.stack.index(stmass, tag = "pred")$data
idx_grace <- pred_idx[1:nrow(A_GRACE_data)]
idx_grid <- pred_idx[-(1:nrow(A_GRACE_data))]

## SSH
mass_m <- INLA_pred$mean[idx_grid] 
mass_u <- INLA_pred$sd[idx_grid]
proj <- inla.mesh.projector(mesh0, projection = "longlat", dims = c(360,180), xlim = c(0,359), ylim = c(-89.5, 89.5))
mass_grid <- expand.grid(proj$x, proj$y)
mass_pred <- data.frame(lon = mass_grid[,1], lat = mass_grid[,2],
                       mean = mass_m,
                       u = mass_u)

res_mass <- list(res_inla = res_inla, spde = mass_spde, st = stmass, 
            mesh = mesh0,  mass_pred = mass_pred)

grace_m <- INLA_pred$mean[idx_grace] 
grace_u <- INLA_pred$sd[idx_grace]
grace_sp@data$pred_mean <- grace_m
grace_sp@data$pred_u <- grace_u


save(res_mass, grace_sp, file ="Z:/WP1-BHM/Experiment2a/exp2a_mass.RData")
```


### Plot the posteriors of the hyper parameters

```{r hyper_grace, include=TRUE}
load("Z:/WP1-BHM/Experiment2a/exp2a_mass.RData")
pars_mass <- marginal_par(res = res_mass, process = "mass", plot = TRUE)
## The posterior modes
print(paste("The estimated correlation lengths are:", pars_mass$rho_mode*6371,  sep = "  "))

print(paste("The estimated marginal variances are:", pars_mass$sigma_mode,sep = "  "))
```


## Plot the predictions

In this experiment, it is more convenient to produce the prediction at the altimetry data directly, since they are grid points.
We plot the predicted SSH at these locations and compare them to the altimetry data
```{r predict_grace, include=TRUE}
mass_pred <- res_mass$mass_pred
mass_pred$source1 <- "mass predicted mean"
mass_pred$source2 <- "mass predicted uncertainty"


## plot the mean 
lattice::levelplot(mean ~ lon + lat, data = mass_pred, aspect = "iso", 
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")

## plot the uncertainty
lattice::levelplot(u ~ lon + lat, data = mass_pred, aspect = "iso", 
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")


spplot(grace_sp, "pred_mean")

spplot(grace_sp, "pred_u")
```


# Update $X_{steric}$

In this experiment, steric can be represented by SSH, MASS and GIA. 
$$X_{steric} = X_{SSH} - X_{MASS} - x_{GIA}$$
Since these processes are all Gaussian, the are additive. We have 
$$E(X_{steric} | Y_{alt}, Y_{GRACE}, X_{GIA} = x_{GIA}) = E(X_{SSH}| ) - E(X_{mass}|Y_{GRACE}) - x_{GIA} \\
V(X_{steric}| Y_{alt}, Y_{GRACE}, X_{GIA} = x_{GIA}) = V(X_{SSH}| Y_{alt}) + V(X_{mass}|Y_{GRACE})$$

## Load GIA data

Here we use the ICE-6G data to fix the GIA.
```{r gia_data, eval = FALSE}
ice6g <- read.table("Z:/WP2-SolidEarth/BHMinputs/GIA/GIA_Pel-6-VM5_ewh.txt", header = T)
ice6g$x_center <- ifelse(ice6g$x_center < 0, ice6g$x_center+360, ice6g$x_center)
ice6g<- ice6g[order(ice6g$y_center,ice6g$x_center ),]
ice6g2 <- read.table("Z:/WP2-SolidEarth/BHMinputs/GIA/GIA_Pel-6-VM5.txt", header = T)
ice6g2<- ice6g2[order(ice6g2$y_center,ice6g2$x_center ),]

ice<-data.frame(x = ice6g$x_center, y = ice6g$y_center, rt = ice6g$trend/ice6g2$trend, rs = ice6g$std/ice6g2$std)

lattice::levelplot(rs ~ x + y, data = ice, aspect = "iso",  at= seq(0, 2, 0.2),
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")
```

## Results

Now assemble the predicted mean of and uncertainty of steric at 1 degree resolution.
```{r setric, eval = FALSE}
steric_m <- res_SSH$SSH_pred$mean - res_mass$mass_pred$mean - ice6g2$trend
steric_u <- res_SSH$SSH_pred$u + res_mass$mass_pred$u
steric_data <- data.frame(lon = ice6g2$x_center, lat = ice6g2$y_center, mean = steric_m, u = steric_u)

```

Plot the steric map.
```{r plot_steric}
load("Z:/WP1-BHM/Experiment2a/exp2a_all.RData")
lattice::levelplot(mean ~ lon + lat, data = steric_data, aspect = "iso",  at = seq(-5, 5, 1),
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")

lattice::levelplot(u ~ lon + lat, data = steric_data, aspect = "iso", at = seq(0, 4, 0.5),
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")
```

# Compare with other steric results

We compare the steric prediction with other four steric solutions.

```{r load_steric}
steric_files <- system(paste("ls", "Z:/WP3-Ocean/BHMinputs/steric/"), intern = TRUE)
steric_models <- c("EN4", "IFEMER", "JAMSTEC", "SCRIPPS", "BHM")

steric_read <- function(file, name){
  filen <- paste0("Z:/WP3-Ocean/BHMinputs/steric/", file)
  steric_nc <- nc_open(filen)
  print(steric_nc)
  lon <-  ncvar_get(steric_nc, "LONGITUDE")
  lon <- ifelse(lon < 0, lon + 360, lon)
  lon <- ifelse(lon > 360, lon - 360, lon)
  lat <- ncvar_get(steric_nc, "LATITUDE")
  grid <- expand.grid(lon, lat)
  trend <- ncvar_get(steric_nc, "trend") #note that there re NAs for land datat
  err <- ncvar_get(steric_nc, "err")
  steric_data <- data.frame(trend = as.numeric(trend), err = as.numeric(err), 
                            model = name, lon = grid[,1], lat = grid[,2])
  nc_close(steric_nc)
  return(steric_data)
}

sterics <- list()

for (i in 1:4){
  sterics[[i]] <- steric_read(steric_files[i], steric_models[i])
}

steric_all <- do.call(rbind, sterics)
steric_bhm <- data.frame(trend = steric_data$mean, err = steric_data$u, 
                         model = "BHM", lon = steric_data$lon, lat = steric_data$lat)
steric_all <- rbind(steric_all, steric_bhm)

```

Now plot and compare the mean trend.
```{r mean_steric}
steric_plot <- steric_all
steric_plot$trend <- ifelse(abs(steric_plot$trend) > 5, sign(steric_plot$trend)*5.5, steric_plot$trend)
steric_plot$err <- ifelse(steric_plot$err > 5, 5.1, steric_plot$err)

lattice::levelplot(trend ~ lon + lat|model, data = steric_plot, aspect = "iso",  
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")

lattice::levelplot(err ~ lon + lat|model, data = steric_plot, aspect = "iso",  
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")
```