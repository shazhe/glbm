---
title: "Experiment 2a"
author: "Z Sha"
date: "22 November 2017"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In this experiment, we assume the GIA is knonw so there will be only two independent latent process $X_{ssh}$ and $X_{mass}$ and the thrid one $X_{steric}$ is given by $X_{steric} = X_{ssh} - x_{GIA} - X_{mass}$. Given the altimetry and GRACE data, the $X_{steric}$ can be predicted as an linear combination of posterior ssh and mass change:
$$X_{steric} |  Y_{alt}, Y_{GRACE} = X_{ssh} | Y_{alt} - X_{mass}|Y_{GRACE} - x_{GIA}$$

Therefore, in the following we use the same approach as in Experiment 1 to obtain the updated $X_ssh$ and $X_{mass}$. In this first experiment we assume these two process can be updated indepenently. 

```{r loadlibs}
library(rgdal); library(sp);library(GEOmap)
library(INLA)
source("~/glbm/BHM_sphere/functions.R")
source("~/glbm/BHM_sphere/functions-barriers-dt-models-march2017.R")
```

# Update $X_{ssh}$

The sea surface height is only defined on oceans so we will model this process only on the ocean. The following chunk load the low resolution global ocean polygons from NatureEarth and generate mesh with equal area triangles of approximately one degree resolution.

## Generate mesh 

```{r ssh_mesh}
## Load the Ocean polygon
Ocean <- readOGR(dsn = "~/glbm/maps/ne_110m_ocean", layer = "ne_110m_ocean")
plot(Ocean)

## Genereate Fibonacci points on the sphere
fibo_points <- fiboSphere(N = 12960, L0 = TRUE)
fibo_points_xyz <- do.call(cbind, Lll2xyz(lat = fibo_points[,2], lon = fibo_points[,1]))
mesh0 <- inla.mesh.2d(loc = fibo_points_xyz, cutoff = 0.01, max.edge = 0.5)

## Remove mesh not in teh ocean
mesh0 <- dt.mesh.addon.posTri(mesh = mesh0, globe = TRUE)
Tlonlat <- Lxyz2ll(list(x = mesh0$posTri[,1], y = mesh0$posTri[,2], z = mesh0$posTri[,3]))
mesh0$Trill <- cbind(lon = Tlonlat$lon, lat =Tlonlat$lat)
TinOcean <- unlist(over(Ocean, SpatialPoints(coords=mesh0$Trill, proj4string = CRS(proj4string(Ocean))), returnList=T))
TAll <- 1:mesh0$t
ToutOcean <- TAll[-TinOcean]
Omega = dt.Omega(list(TinOcean, 1:mesh0$t), mesh0)

mesh_ssh <- mesh.sub(mesh0, Omega, 1)
summary(mesh_ssh)
```

## Load data 

Now load the pre-processed altimetry data.
```{r alt_data}
library(ncdf4)
alt_nc <- nc_open("glbm/Experiment2/trend_SSH_CCI_200501_201512.nc")
print(alt_nc)
lon <- ncvar_get(alt_nc, "lon")
lat <- ncvar_get(alt_nc, "lat")
trend_ssh <- ncvar_get(alt_nc, "trend_ssh") #note that there re NAs for land datat
err_ssh <- ncvar_get(alt_nc, "err")

alt_data <- data.frame(trend_ssh = as.numeric(trend_ssh), err_ssh = as.numeric(err_ssh))
alt_data$lon <- rep(lon, 180) 
alt_data$lat <- rep(lat, each = 360)
alt_data2 <- na.omit(alt_data)
## Find the xyz coords of the altimetry data
alt_loc <- do.call(cbind, Lll2xyz(lon = alt_data2$lon, lat = alt_data2$lat))
## plot the data
lattice::levelplot(trend_ssh ~ lon + lat, data = alt_data2, aspect = "iso",  at =seq(-20, 20, 4),
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")

lattice::levelplot(err_ssh ~ lon + lat, data = alt_data2, aspect = "iso",  at = seq(0, 4, 0.5),
                     panel = function(x,y,z,...){
                       lattice::panel.levelplot(x,y,z,...)
                       map2 <- map("world2", interior = FALSE, plot = FALSE)
                       lattice::panel.xyplot(x=map2$x, y=map2$y, type = "l", col = "black")
                     },
                     main = title, xlab = "longitude", ylab = "latitude")
```

## prior set up

## Link data to process

## INLA inference

## Results






# Update $X_{mass}$

## Generate mesh 

## Load data 

## prior set up

## Link data to process

## INLA inference

## Results




# Update $X_{steric}$

## Load GIA data

## Results