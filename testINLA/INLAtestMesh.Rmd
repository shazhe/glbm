# Test INLA Mesh effects

***

We test the mesh effect on the marginal variances of Gaussian processes on $R^2$ and $S^2$ using the INLA package. The reason is that for a stationary Gaussian process, we would expect the marginal variances to be constant (at least within the boundary) however, we have observed non-constant variances: for irregular mesh, the differences are random and huge; while for regular mesh, the differences show certain pattern at the boundary or where the triangles change shapes.


Based on results (need references) of the finite element methods for SPDEs, we have the following statements

* The non-constant variance is caused by the shape change of the triangles.

* For regular mesh, when the triangles get small enough, the mesh effect should dis sapper.
    * How small is enough?
    * Relationship between maximum triangle edge length and the process correlation length.
    * Maximum edge < < correlation length? Or the other way round?

* For different high resolution meshes, the inferences on the parameters should be similar.

Therefore, in the following we tests the above statements first on $R^2$ then $S^2$. The first statement is obvious and we focus on the other two. Without loss of generality, we choose to test on a the square $[0,1] \times [0,1] \subset R^2$ and to reduce the boundary effects, the square is wrapped by a convex hull.

***

## 1. Marginal variances for a stationary process

### 1.1 Regular grid on $R^2$

We first test on $R^2$. The correlation length is fixed to be $\rho = 0.1$ and variance to be $\sigma^2 = 1$. The regular grid is generated by using equally spaced grid points and we increase the number of points in each dimension to have smaller triangles. To make sure the triangles are all the same within the boundary, we choose the maximum edge length to be $\sqrt{2}/l$, where $l$ is the number of segments in $x$ (or $y$) direction.


```{r warning=FALSE, message=FALSE, cache=TRUE}
library(INLA)
library(lattice)
library(fields)

## a wrapper for generating mesh, evaluating the variance and plot the result
plot.mvar <- function(range0, locres, max.edge, plot.mesh = TRUE, xylim = FALSE){
  sigma0 <- 1
  loc <- as.matrix(expand.grid(seq(0, 1, locres), seq(0, 1, locres)))
  mesh <- inla.mesh.2d(loc = loc, offset = c(0.1, 0.4), max.edge = max.edge )
  lkappa0 <- log(8)/2 - log(range0)
  ltau0 <- 0.5*log(1/(4*pi)) - log(sigma0) - lkappa0
  
  spde <- inla.spde2.matern(mesh, B.tau = matrix(c(ltau0, -1, 1),1,3),
                            B.kappa = matrix(c(lkappa0, 0, -1), 1,3), 
                            theta.prior.mean = c(0,0), theta.prior.prec = c(0.1, 1))
  Q <- inla.spde.precision(spde, theta = c(0,0))
  msd <- sqrt(1/diag(Q))
  proj <- inla.mesh.projector(mesh, dims = c(100,100))
  
  if(xylim){
    image.plot(proj$x, proj$y, inla.mesh.project(proj, as.vector(msd)), 
             col = topo.colors(24), breaks = seq(0, 1.2, 0.05),
             xlim = c(0,1), ylim = c(0,1), xlab = "", ylab="",
             main = paste("edge length = ", locres))
  }else{
      image.plot(proj$x, proj$y, inla.mesh.project(proj, as.vector(msd)), 
                 col = topo.colors(24), breaks = seq(0, 1.2, 0.05),
                 xlab = "", ylab="",
                 main = paste("edge length = ", locres))
    }
  
  if(plot.mesh){
    plot(mesh, add = TRUE)}
}

### fix range and vary grid size
par(mfrow = c(2,3))
plot.mvar(range0=0.1, locres = 0.3, max.edge = c(0.45, 0.45))
plot.mvar(range0=0.1, locres = 0.2, max.edge = c(0.3, 0.3))
plot.mvar(range0=0.1, locres = 0.1, max.edge = c(0.15, 0.15))
plot.mvar(range0=0.1, locres = 0.08, max.edge = c(0.12, 0.12), plot.mesh = FALSE)
plot.mvar(range0=0.1, locres = 0.04, max.edge = c(0.06, 0.06), plot.mesh = FALSE)
plot.mvar(range0=0.1, locres = 0.02, max.edge = c(0.03, 0.03), plot.mesh = FALSE)
```


#### Remarks

The true standard error should be equal to 1 and the closest in the above plots is the those with edge length around 0.1 which is also the correlation length of the process. The standard error is under approximated using either a low or high resolution grid. 

**_We may conclude that the best resolution of the mesh would be the one with triangle length approximately equal to the process correlation length._**


### 1.2 Semi-regular grid on $S^2$
Next we do the same text on $S^2$. Note that on $S^2$ it is not possible to generate a mesh that is entirely regular. We used the INLA function to generate a semi-regular mesh based on evenly segmenting the edges of an icosahedron.


```{r warning=FALSE, message=FALSE, cache=TRUE}

## a wrapper for generating mesh on the sphere, evaluating the variance and plot the result
plot.mvarS2 <- function(range0, nseg){
  sigma0 <- 1
  mesh <- inla.mesh.create(globe = nseg)
  
  lkappa0 <- log(8)/2 - log(range0)
  ltau0 <- 0.5*log(1/(4*pi)) - log(sigma0) - lkappa0
  
  spde <- inla.spde2.matern(mesh, B.tau = matrix(c(ltau0, -1, 1),1,3),
                            B.kappa = matrix(c(lkappa0, 0, -1), 1,3), 
                            theta.prior.mean = c(0,0), theta.prior.prec = c(0.1, 0.1))
  Q <- inla.spde.precision(spde, theta = c(0,0))
  msd <- sqrt(1/diag(Q))
  proj <- inla.mesh.projector(mesh, dims = c(360,181))

  image.plot(proj$x, proj$y, inla.mesh.project(proj, as.vector(msd)), 
             col = topo.colors(40), breaks = seq(0,1,0.025),
             xlab = "", ylab="",
             main = paste("edge length = ", 1/nseg))
}

### fix range and vary grid size
par(mfrow = c(2,3))
plot.mvarS2(range0=0.1, nseg = 2)
plot.mvarS2(range0=0.1, nseg = 5)
plot.mvarS2(range0=0.1, nseg = 10)
plot.mvarS2(range0=0.1, nseg = 20)
plot.mvarS2(range0=0.1, nseg = 50)
plot.mvarS2(range0=0.1, nseg = 100)
```

#### Remarks

The mesh effect due to the shape change of triangles can not be eliminated but the variation becomes negligible when the edge length of the triangles are similar to the correlation length and the variance approximation is also more accurate.

***

## 2. Inference on the parameters

Now we test the mesh effect on parameter inference.

### 2.1 On $R^2$

Here we compare posterior marginal distributions of the hyper parameters, $\rho$ and $\sigma^2$ from four different meshes using simulated data. The four meshes include three regular meshes with maximum edge length larger, approximately equal and smaller than the correlation length and an irregular mesh with maximum edge length approximately equal to the correlation length.

In the following experiment, we assume the true process has $\rho = 0.05, \sigma^2 = 1$ and we again study the region $[0,1] \times [0,1] \subset R^2$.

First we simulate data from the true process on a fine grid.
```{r warning=FALSE, message=FALSE, cache=TRUE}
## Simulate the true process on a fine grid
set.seed(12)
data_grid <- as.matrix(expand.grid(seq(0, 1, 0.01), seq(0, 1, 0.01)))
locdist <- as.matrix(dist(data_grid))
data_cov <- Matern(d =locdist, range = 0.05, smoothness = 1, phi = 1) # to be compared with inla: smoothness(nu) = alpha - d/2
data_chol <- chol(data_cov) 
data_vec <- data_chol %*% rnorm(nrow(data_grid))
simdata <- data.frame(x = data_grid[,1], y = data_grid[,2], z = data_vec)
```

```{r warning=FALSE, message=FALSE}
library(ggplot2)
true_process <- ggplot(simdata) + coord_fixed() + scale_x_continuous(limits=c(0,1),  expand = c(0.02, 0.02)) + 
    scale_y_continuous(limits=c(0,1),  expand = c(0.02, 0.02)) + 
  geom_raster(aes(x = x, y = y, fill = z)) + 
  scale_fill_gradientn(colours = terrain.colors(12), limit = c(-4,4)) +
  ggtitle("Simulated data from the true process") 
print(true_process)
```


From this grid we sample 500 data points as our observations.
```{r warning=FALSE, message=FALSE}
obs_ind <- sample(1:length(data_vec), 1000)
obs_data <- data.frame(x = data_grid[obs_ind, 1], y = data_grid[obs_ind, 2], z = data_vec[obs_ind] + rnorm(1000)*0.1)
sample_data <- true_process + geom_point(data=obs_data, aes(x, y), pch = 20, size = 0.5) + ggtitle("Sampled observations") 
print(sample_data)
```


Then we generate four different meshes: 3 regular meshes with increasing resolution and 1 irregular grid with resolution similar to the range.
```{r warning=FALSE, message=FALSE}
## generate 4 different meshes
## Regular
mesh1 <- inla.mesh.2d(loc = as.matrix(expand.grid(seq(0, 1, 0.1), seq(0, 1, 0.1))), 
                      offset = c(0.1, 0.4), max.edge = c(0.15, 0.15))
mesh2 <- inla.mesh.2d(loc = as.matrix(expand.grid(seq(0, 1, 0.05), seq(0, 1, 0.05))), 
                      offset = c(0.1, 0.4), max.edge = c(0.08, 0.08))
mesh3 <- inla.mesh.2d(loc = as.matrix(expand.grid(seq(0, 1, 0.01), seq(0, 1, 0.01))), 
                      offset = c(0.1, 0.4), max.edge = c(0.015, 0.015))
## Irregular
data_loc <- cbind(x = obs_data[,1], y = obs_data[,2])
mesh4 <- inla.mesh.2d(loc = data_loc, cutoff = 0.05, offset = c(0.1, 0.4), max.edge = c(0.08, 0.08))
mesh5 <- inla.mesh.2d(loc = data_loc, cutoff = 0.01, offset = c(0.1, 0.4), max.edge = c(0.015, 0.015))
mesh_names <- c("r - 0.15", "r - 0.08", "r - 0.015", "ir - 0.08", "ir - 0.015")
```

Now with the data and four meshes, we use INLA to do the parameter inference and prediction.
```{r warning=FALSE, message=FALSE, cache=TRUE}
## set prior values for the hyper parameters, delibrately set to be different from the truth.
sigma0 <- 0.5
range0 <- 0.5

lkappa0 <- log(8)/2 - log(range0)
ltau0 <- 0.5*log(1/(4*pi)) - log(sigma0) - lkappa0

## A wrapper to do the INLA inference and prediction
INLA_infer <- function(mesh, data){
  spde <- inla.spde2.matern(mesh, B.tau = matrix(c(ltau0, -1, 1),1,3), B.kappa = matrix(c(lkappa0, 0, -1), 1,3), 
                          theta.prior.mean = c(0,0), theta.prior.prec = c(0.01, 0.01))
  
  data_loc <- cbind(x = data[,1], y = data[,2], z = rep(0, nrow(data)))
  Ay <- inla.spde.make.A(mesh = mesh, loc = data_loc)
  st.est <- inla.stack(data = list(y=data$z), A = list(Ay),
                     effects = list(process = 1:spde$n.spde), tag = "est")
  
  hyper <- list(prec = list(fixed = TRUE, initial = log(1)))
  formula = y ~ -1 + f(process, model = spde)
  prec_scale <- 1/(0.1^2)
  
  res_inla <- inla(formula, data = inla.stack.data(st.est, spde = spde), family = "gaussian",
                  scale = prec_scale, control.family = list(hyper = hyper),
                   control.predictor=list(A=inla.stack.A(st.est), compute =TRUE))
  ## the parameters
  res_pars <- inla.spde2.result(res_inla, "process", spde, do.transf=TRUE)
  
  ## the predictions
  proj <- inla.mesh.projector(mesh,dims = c(500,500))
  mean_post <- res_inla$summary.random$process$mean
  sd_post <- res_inla$summary.random$process$sd
  
  return(list(pars = res_pars, proj = proj, mean = mean_post, sd = sd_post))
}

res1 <- INLA_infer(mesh1, obs_data)
res2 <- INLA_infer(mesh2, obs_data)
res3 <- INLA_infer(mesh3, obs_data)
res4 <- INLA_infer(mesh4, obs_data)
res5 <- INLA_infer(mesh5, obs_data)
```

Compare the posteriors of the parameters from the four meshes.
```{r warning=FALSE, message=FALSE}
pars1 <- res1$pars
pars2 <- res2$pars
pars3 <- res3$pars
pars4 <- res4$pars
pars5 <- res5$pars
## Plot the range 
 plot(pars1$marginals.range.nominal[[1]], type = "l",
      main = "range", xlim = c(0,0.35), ylim = c(0, 50))
 lines(pars2$marginals.range.nominal[[1]], col = 2)
 lines(pars3$marginals.range.nominal[[1]], col = 4)
 lines(pars4$marginals.range.nominal[[1]], col = 2, lty = 2)
 lines(pars5$marginals.range.nominal[[1]], col = 4, lty = 2)
 legend("topright", legend = mesh_names, lwd = rep(1,5), 
        lty = c(1,1,1,2,2), col = c(1, 2, 4, 2, 4))

## Plot the marginal variance
plot(pars1$marginals.variance.nominal[[1]], type = "l",
     main = "marginal variance", xlim = c(0, 4), ylim = c(0,4.5))
lines(pars2$marginals.variance.nominal[[1]], col = 2)
lines(pars3$marginals.variance.nominal[[1]], col = 4)
lines(pars4$marginals.variance.nominal[[1]], col = 2, lty = 2)
lines(pars5$marginals.variance.nominal[[1]], col = 4, lty = 2)
legend("topright", legend = mesh_names, lwd = rep(1,5), 
       lty = c(1,1,1,2,2), col = c(1, 2, 4, 2, 4))

```

Finally we compare the predicted mean field.
```{r warning=FALSE, message=FALSE}
plot_mean <- function(res, title){
  xygrid <- expand.grid(res$proj$x, res$proj$y)
  z <- as.vector(inla.mesh.project(res$proj, as.vector(res$mean)))
  preddata <- data.frame(x=xygrid[,1], y = xygrid[,2], z = z)
  ggplot(preddata) + coord_fixed() + scale_x_continuous(limits=c(0,1),  expand = c(0.02, 0.02)) + 
    scale_y_continuous(limits=c(0,1),  expand = c(0.02, 0.02)) +
    geom_raster(aes(x = x, y = y, fill = z)) + 
    scale_fill_gradientn(colours = terrain.colors(12), limit = c(-4,4)) +
    ggtitle(title)
}


m1 <- plot_mean(res1, title = mesh_names[1])

m2 <- plot_mean(res2, title = mesh_names[2])

m3 <- plot_mean(res3, title = mesh_names[3])

m4 <- plot_mean(res4, title = mesh_names[4])

m5 <- plot_mean(res5, title = mesh_names[5])

library(grid)
library(gridExtra)
grid.arrange(true_process, m1, m2, m3, m4, m5, ncol = 2)
```

And also compare the predicted uncertainties.
```{r warning=FALSE, message=FALSE}
plot_sd <- function(res, title){
  xygrid <- expand.grid(res$proj$x, res$proj$y)
  sd <- as.vector(inla.mesh.project(res$proj, as.vector(res$sd)))
  preddata <- data.frame(x=xygrid[,1], y = xygrid[,2], sd = sd)
  ggplot(preddata) + coord_fixed() + scale_x_continuous(limits=c(0,1),  expand = c(0.02, 0.02)) + 
    scale_y_continuous(limits=c(0,1),  expand = c(0.02, 0.02)) +
    geom_raster(aes(x = x, y = y, fill = sd)) + geom_point(data=obs_data, aes(x, y), size = 0.3, pch = 20)+
    scale_fill_gradientn(colours = terrain.colors(12), limit = c(0.05,2)) +
    ggtitle(title)
}

sd1 <- plot_sd(res1, title = mesh_names[1])
sd2 <- plot_sd(res2, title = mesh_names[2])
sd3 <- plot_sd(res3, title = mesh_names[3])
sd4 <- plot_sd(res4, title = mesh_names[4])
sd5 <- plot_sd(res5, title = mesh_names[5])
print(sd1)
grid.arrange(sd2, sd4, ncol = 2)
grid.arrange(sd3, sd5, ncol = 2)
```

The best mesh for parameter estimation is the regular mesh with the resolution similar to the correlation length but it is not good for prediction as details get blurred due to the its sparseness.


### 2.2 Test stabilities 
The Same experiment is replicated 100 times for each mesh with different simulated data.
```{r warning=FALSE, message=FALSE, cache=TRUE}

repFun <- function(){
data_vec <- data_chol %*% rnorm(nrow(data_grid))
obs_ind <- sample(1:length(data_vec), 1000)
obs_data <- data.frame(x = data_grid[obs_ind, 1], y = data_grid[obs_ind, 2], z = data_vec[obs_ind] + rnorm(1000)*0.1)
INLA_infer(mesh2, obs_data)
}

replicate(2, repFun())
```


